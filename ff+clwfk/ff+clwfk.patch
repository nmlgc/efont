--- Makefile.in.orig	Thu Oct 26 23:21:01 2006
+++ Makefile.in	Sun Nov 12 11:21:59 2006
@@ -52,6 +52,7 @@
 	#-rm $(libdir)/libgdraw.so* $(libdir)/libgunicode.so.*
 	$(LIBTOOL) --mode=install $(INSTALL) -c libgunicode.la $(libdir)/libgunicode.la
 	$(LIBTOOL) --mode=install $(INSTALL) -c libgdraw.la $(libdir)/libgdraw.la
+	$(LIBTOOL) --mode=install $(INSTALL) -c libgunicode.la $(libdir)/libfontforge.la
 	$(LIBTOOL) --mode=finish $(libdir)
 	mkdir -p $(libdir)/pkgconfig
 	$(INSTALL_DATA) fontforge.pc $(libdir)/pkgconfig
@@ -99,6 +100,7 @@
 	-rm $(mandir)/man1/sfddiff.1
 	-rm $(libdir)/libgdraw.so*
 	-rm $(libdir)/libgunicode.so*
+	-rm $(libdir)/libfontforge.so*
 	-rm $(sharedir)/*.cidmap
 	-rm -rf $(docdir)/*
 
--- fontforge/Makefile.dynamic.in.orig	Thu Oct 26 23:21:01 2006
+++ fontforge/Makefile.dynamic.in	Sun Nov 12 12:23:26 2006
@@ -10,6 +10,10 @@
 libdir = @libdir@
 plugindir = $(sharedir)/plugins
 
+FF_VERSION=1
+FF_REVISION=9
+FF_AGE=0
+
 LIBTOOL = @LIBTOOL@
 CC = @CC@
 
@@ -20,32 +24,57 @@
 X_PRE_LIBS = @X_PRE_LIBS@
 STATIC_LIBS = @STATIC_LIBS@
 
-fontforge_LIBOBJECTS =  autohint.o autosave.o autowidth.o bitmapdlg.o \
- bitmapview.o bvedit.o charview.o charviewicons.o cursors.o \
- cvaddpoints.o cvexport.o cvgetinfo.o cvhints.o cvimages.o cvknife.o \
- cvpalettes.o cvpointer.o cvruler.o cvshapes.o cvstroke.o cvtranstools.o \
- cvundoes.o dumpbdf.o dumppfa.o fontinfo.o fontview.o fvcomposit.o \
- fvfonts.o fvimportbdf.o fvmetrics.o images.o metricsview.o \
- parsepfa.o parsettf.o prefs.o psread.o namelist.o savefontdlg.o \
- sfd.o splashimage.o splinefill.o splineoverlap.o splinesave.o \
- splinesaveafm.o splinestroke.o splineutil.o splineutil2.o stamp.o \
- start.o tottf.o transform.o uiutil.o utils.o windowmenu.o  \
- zapfnomen.o othersubrs.o autotrace.o openfontdlg.o encoding.o print.o \
- problems.o metafont.o alignment.o parsettfbmf.o \
- macbinary.o crctab.o scripting.o freetype.o gotodlg.o search.o \
- combinations.o tilepath.o sftextfield.o displayfonts.o ikarus.o \
- cvhand.o cvfreehand.o simplifydlg.o winfonts.o tottfgpos.o tottfaat.o \
- charinfo.o splineorder2.o genttfinstrs.o ttfinstrs.o cvgridfit.o \
- cvdebug.o showatt.o kernclass.o nonlineartrans.o effects.o \
- histograms.o ttfspecial.o svg.o parsettfatt.o contextchain.o \
- macenc.o statemachine.o typofeatures.o splinerefigure.o mm.o \
- parsettfvar.o tottfvar.o pua.o stemdb.o anchorsaway.o palmfonts.o \
- cvdgloss.o groups.o parsepdf.o plugins.o bdfinfo.o \
- glyphcomp.o unicoderange.o @FF_EXTRA_FILES@
+# all files except for main.c, acorn2sfd.c, sfddiff.c, diffstubs.c, stamper.c
+libfontforge_OBJECTS = alignment.lo anchorsaway.lo autohint.lo autosave.lo \
+ autotrace.lo autowidth.lo bdfinfo.lo bitmapdlg.lo bitmapview.lo bvedit.lo \
+ charinfo.lo charview.lo charviewicons.lo combinations.lo \
+ contextchain.lo crctab.lo cursors.lo cvaddpoints.lo cvdebug.lo \
+ cvdgloss.lo cvexport.lo cvfreehand.lo cvgetinfo.lo cvgridfit.lo \
+ cvhand.lo cvhints.lo cvimages.lo cvknife.lo cvpalettes.lo cvpointer.lo \
+ cvruler.lo cvshapes.lo cvstroke.lo cvtranstools.lo cvundoes.lo \
+ displayfonts.lo dumpbdf.lo dumppfa.lo effects.lo encoding.lo \
+ fontinfo.lo fontview.lo freetype.lo fvcomposit.lo fvfonts.lo \
+ fvimportbdf.lo fvmetrics.lo genttfinstrs.lo glyphcomp.lo gotodlg.lo \
+ groups.lo histograms.lo ikarus.lo images.lo kernclass.lo macbinary.lo \
+ macenc.lo metafont.lo metricsview.lo mm.lo namelist.lo \
+ nonlineartrans.lo openfontdlg.lo othersubrs.lo palmfonts.lo \
+ parsepdf.lo parsepfa.lo parsettf.lo parsettfatt.lo parsettfbmf.lo \
+ parsettfvar.lo plugins.lo prefs.lo print.lo problems.lo psread.lo \
+ pua.lo savefontdlg.lo scripting.lo search.lo sfd.lo sftextfield.lo \
+ showatt.lo simplifydlg.lo splashimage.lo splinefill.lo splineorder2.lo \
+ splineoverlap.lo splinerefigure.lo splinesave.lo splinesaveafm.lo \
+ splinestroke.lo splineutil.lo splineutil2.lo stamp.lo \
+ start.lo statemachine.lo stemdb.lo svg.lo threaddummy.lo tilepath.lo \
+ tottf.lo tottfaat.lo tottfgpos.lo tottfvar.lo transform.lo \
+ ttfinstrs.lo ttfspecial.lo typofeatures.lo uiutil.lo unicoderange.lo \
+ utils.lo windowmenu.lo winfonts.lo zapfnomen.lo
+fontforge_LIBOBJECTS = alignment.o anchorsaway.o autohint.o autosave.o \
+ autotrace.o autowidth.o bdfinfo.o bitmapdlg.o bitmapview.o bvedit.o \
+ charinfo.o charview.o charviewicons.o combinations.o \
+ contextchain.o crctab.o cursors.o cvaddpoints.o cvdebug.o \
+ cvdgloss.o cvexport.o cvfreehand.o cvgetinfo.o cvgridfit.o \
+ cvhand.o cvhints.o cvimages.o cvknife.o cvpalettes.o cvpointer.o \
+ cvruler.o cvshapes.o cvstroke.o cvtranstools.o cvundoes.o \
+ displayfonts.o dumpbdf.o dumppfa.o effects.o encoding.o \
+ fontinfo.o fontview.o freetype.o fvcomposit.o fvfonts.o \
+ fvimportbdf.o fvmetrics.o genttfinstrs.o glyphcomp.o gotodlg.o \
+ groups.o histograms.o ikarus.o images.o kernclass.o macbinary.o \
+ macenc.o metafont.o metricsview.o mm.o namelist.o \
+ nonlineartrans.o openfontdlg.o othersubrs.o palmfonts.o \
+ parsepdf.o parsepfa.o parsettf.o parsettfatt.o parsettfbmf.o \
+ parsettfvar.o plugins.o prefs.o print.o problems.o psread.o \
+ pua.o savefontdlg.o scripting.o search.o sfd.o sftextfield.o \
+ showatt.o simplifydlg.o splashimage.o splinefill.o splineorder2.o \
+ splineoverlap.o splinerefigure.o splinesave.o splinesaveafm.o \
+ splinestroke.o splineutil.o splineutil2.o stamp.o \
+ start.o statemachine.o stemdb.o svg.o threaddummy.o tilepath.o \
+ tottf.o tottfaat.o tottfgpos.o tottfvar.o transform.o \
+ ttfinstrs.o ttfspecial.o typofeatures.o uiutil.o unicoderange.o \
+ utils.o windowmenu.o winfonts.o zapfnomen.lo
 DIFFOBJS = sfddiff.o sfd.o diffstubs.o stamp.o namelist.o pua.o
 ACORNOBJS = acorn2sfd.o sfd.o diffstubs.o psunicodenames.o stamp.o
 
-_CFLAGS = -I$(top_srcdir)/inc -I$(srcdir) -I. @WFLAGS@ $(X_CFLAGS) \
+_CFLAGS = -I$(LOCALBASE)/include -I$(top_srcdir)/inc -I$(srcdir) -I. @WFLAGS@ $(X_CFLAGS) \
     @DEFS@ '-DSHAREDIR="$(sharedir)"' -DLIBDIR='"$(libdir)"' \
     @CPPFLAGS@ '-DPREFIX="@prefix@"'
 CFLAGS = @CFLAGS@ $(_CFLAGS)
@@ -53,10 +82,15 @@
 #I used to include -L/usr/lib explicitly after static_libs. Not sure why. Should be implied & breaks 64bit compiles
 LDFLAGS = @LDFLAGS@
 LIBS = -rpath $(libdir) $(X_LIBS) ../libgdraw.la ../libgunicode.la \
-    $(X_PRE_LIBS) $(X_11LIB) $(X_EXTRA_LIBS) @LIBS@ $(STATIC_LIBS) -lm
-DLIBS = -rpath $(libdir) ../libgunicode.la @LIBS@ $(STATIC_LIBS) -lm
+    $(X_PRE_LIBS) $(X_11LIB) $(X_EXTRA_LIBS) @LIBS@ $(STATIC_LIBS) -lm -lintl
+DLIBS = -rpath $(libdir) ../libgunicode.la @LIBS@ $(STATIC_LIBS) -lm -lintl
+
+all: fontforge sfddiff fontimage ../libfontforge.la
 
-all: fontforge sfddiff fontimage
+../libfontforge.la: $(libfontforge_OBJECTS)
+	$(LIBTOOL) --mode=link $(CC) $(CFLAGS) @LDFLAGS@ -o ../libfontforge.la $(libfontforge_OBJECTS) \
+	    $(STATIC_LIBS) \
+	    -rpath $(libdir) -version-info $(FF_VERSION):$(FF_REVISION):$(FF_AGE)
 
 fontforge: main.o $(fontforge_LIBOBJECTS)
 	$(LIBTOOL) --mode=link $(CC) -export-dynamic $(LDFLAGS) -o fontforge main.o $(fontforge_LIBOBJECTS) $(LIBS)
@@ -90,6 +124,9 @@
 
 %.o: %.c $(srcdir)/splinefont.h $(srcdir)/views.h $(srcdir)/stemdb.h $(srcdir)/ttf.h $(srcdir)/unicoderange.h $(srcdir)/psfont.h $(srcdir)/groups.h $(srcdir)/edgelist.h $(srcdir)/edgelist2.h
 	$(CC) $(CFLAGS) -c $<
+
+%.lo: %.c
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) -c $<
 
 clean:
 	-rm -f *.o *.o fontforge sfddiff po/*.mo
--- fontforge/autotrace.c.orig	Fri Jan 13 11:25:40 2006
+++ fontforge/autotrace.c	Fri Mar 17 20:35:32 2006
@@ -199,7 +199,6 @@
     fd = mkstemp(buffer);
 #if 0
     old = copy(buffer);
-    strcat(buffer,".bmp");
     if ( rename(old,buffer)==-1 )
 	strcpy(buffer,old);
     free(old);
@@ -232,6 +231,408 @@
 return( NULL );
     }
 }
+
+#ifdef FONTFORGE_CONFIG_CLWFK
+void SCBuildSkeleton(SplineChar *sc, char *arg) {
+    char *prog = "/home/kanou/clwfk.run";
+    char *arglist[30];
+    int ac;
+    int pid, status;
+
+    ac = 0; 
+    arglist[ac++] = "/bin/sh";
+    arglist[ac++] = prog;
+//    arglist[ac++] = u2utf8_copy(arg);
+   arglist[ac++] = arg;
+    arglist[ac] = NULL;
+    if ( (pid=fork())==0 ) {
+	  /* Child */
+	  exit(execvp("/bin/sh",arglist)==-1);	/* If exec fails, then die */
+//	  exit(execvp(prog,arglist)==-1);	/* If exec fails, then die */
+    } else if ( pid!=-1 ) {
+          waitpid(pid,&status,0);
+    }
+}
+
+static char *lispname = NULL;
+static char *clwfkdirname = NULL;
+static char *clwfk_default_dir = "/usr/local/share/wadalab-fontkit";
+static char *default_lisp_name = "/usr/local/bin/lisp";
+
+static char *FindLispName(void) {
+    if ( lispname==NULL )
+	lispname = getenv("LISP");
+    if ( lispname==NULL && access(default_lisp_name, X_OK)==0 )
+	lispname = default_lisp_name;
+return lispname;
+}
+
+static char *FindClwfkDirName(void) {
+    DIR *dirp;
+    struct dirent *dp;
+
+    if ( clwfkdirname==NULL )
+	clwfkdirname = getenv("CLWFKDIR");
+    if ( clwfkdirname==NULL ) {
+	dirp = opendir(".");
+	while ((dp = readdir(dirp)) != NULL) {
+	    if (strcmp(dp->d_name, "wadalab-fontkit") == 0)
+		clwfkdirname = "./wadalab-fontkit";
+	    else if (strcmp(dp->d_name, "wadalabkit") == 0)
+		clwfkdirname = "./wadalabkit";
+	    if (clwfkdirname!=NULL)
+	break;
+	}
+	if (dirp!=NULL)
+	    closedir(dirp);
+    }
+    if ( clwfkdirname==NULL )
+	if ((dirp=opendir(clwfk_default_dir)) != NULL) {
+	    clwfkdirname = clwfk_default_dir;
+	    closedir(dirp);
+	}	    
+
+return clwfkdirname;
+}
+
+#include <iconv.h>
+static char iconvbuf[2048];
+
+static char *utf8_to_eucjp(const char *str) {
+    static iconv_t cvt;
+    char *bufp = iconvbuf;
+    size_t len = strlen(str);
+    size_t oleft = sizeof(iconvbuf);
+    const char **sp = &str;
+
+    if (cvt == NULL)
+	cvt = iconv_open("EUC-JP", "UTF-8");
+    iconv(cvt, sp, &len, &bufp, &oleft);
+    *bufp = '\0';
+    return iconvbuf;
+}
+
+static char *eucjp_to_utf8(const char *str) {
+    static iconv_t cvt;
+    char *bufp = iconvbuf;
+    size_t len = strlen(str);
+    size_t oleft = sizeof(iconvbuf);
+    const char **sp = &str;
+
+    if (cvt == NULL)
+	cvt = iconv_open("UTF-8", "EUC-JP");
+    iconv(cvt, sp, &len, &bufp, &oleft);
+    *bufp = '\0';
+    return iconvbuf;
+}
+
+typedef struct lispinfo {
+    char *dir;
+    char *prog;
+    char *arglist[30];
+    char tempname[1025];
+    int ac;
+    int fd;
+    FILE *out;
+} LispInfo;
+
+static int PrepareLispFile (LispInfo *lisp) {
+    lisp->fd = mytempnam(lisp->tempname);
+    if ( (lisp->dir=FindClwfkDirName()) == NULL ) {
+	gwwv_post_error(_("CLWFK renderer not found"), _("CLWFK renderer not found"));
+return ( 1 );
+    }
+    if ( (lisp->prog=FindLispName())==NULL ) {
+	gwwv_post_error(_("Lisp interpreter (CMUCL) not found"),_("Lisp interpreter (CMUCL) not found"));
+return ( 1 );
+    }
+
+    lisp->ac = 0;
+    lisp->arglist[lisp->ac++] = lisp->prog;
+    /* currently CMUCL only */
+    lisp->arglist[lisp->ac++] = "-quiet";
+    lisp->arglist[lisp->ac++] = "-batch";
+    lisp->arglist[lisp->ac++] = "-load";
+    lisp->arglist[lisp->ac++] = lisp->tempname;
+    lisp->arglist[lisp->ac++] = NULL;
+return ( 0 );
+}
+
+static void PrintLispHeader(FILE *prog, char *clwfkdir, int loadkanjidata) {
+    fputs("(setq *top-level-auto-declare* t)\n"
+	  "(defvar base-directory)\n"
+	  "(defparameter source-load nil)\n"
+	  "(defun load-directory (dir)\n"
+	  "(let* ((base-directory dir))\n"
+	  "	(load (concatenate 'string base-directory \"/\" \"load.l\"))))\n", prog);
+    fprintf(prog, "(load-directory \"%s/renderer/\")\n", clwfkdir);
+    if (loadkanjidata) {
+	fprintf(prog, "(load-directory \"%s/primdata/\")\n", clwfkdir);
+	fprintf(prog, "(load-directory \"%s/jointdata/\")\n", clwfkdir);
+	fprintf(prog, "(load-directory \"%s/kanjidata/\")\n", clwfkdir);
+    }
+}
+
+static int DumpOutlineFlesher(SplineChar *sc, char *face, char *filename, char *clwfkdir, int normkanji) {
+    FILE *prog = fopen(filename, "w");
+    real strokewidth = 70.0;
+    char *glyphname;
+
+    PrintLispHeader(prog,clwfkdir, false);
+    if ( sc->parent->strokewidth != 0 )
+        strokewidth = sc->parent->strokewidth;
+    fprintf(prog, "(setq %swidth %.2f)\n", face, strokewidth / 5.0);
+
+    if ( SkeletonCheck(sc) == 0 )
+return ( -1 );
+    if (ExportSkeletonAndDepends(prog, sc) == 0)
+return( -1 );
+
+    fprintf(prog, "(outline2eps (makeoutline (skeleton2list \n");
+    if (normkanji) fputs("(normkanji ", prog);
+    glyphname = copy(sc->name);
+    fprintf(prog, "(rm-limit (applykanji %s '%s))\n", glyphname, face);
+    free(glyphname);
+    if (normkanji) fputs(")", prog);
+    fprintf(prog, " '%s)))\n",face);
+    fputs("(quit)\n", prog);
+
+    fclose(prog);
+return( 0 );
+}
+
+static int DumpDependsQuery(char *depstr, char *filename, char *clwfkdir) {
+    FILE *prog = fopen(filename, "w");
+
+    PrintLispHeader(prog,clwfkdir, true);
+    fprintf(prog, "\n(print (kanjiusage \'%s))\n", utf8_to_eucjp(depstr));
+    fprintf(prog, "(quit)\n");
+    fclose(prog);
+return( 0 );
+}
+
+static char **dependentGlyphs(SplineFont *sf, FILE *chardef) {
+    static char buf[1024];
+    static char *deps[64];
+    char *p, end, *endp, **dp = deps;
+    char *tmp, *tmp2;
+
+    if ( fread(buf,1,sizeof(buf),chardef)==0 )
+return ( NULL );
+
+    for ( p = buf; ; ) {
+	while ( *p!='\0' && ( isspace(*p) || *p=='\n' || *p=='\r' || *p=='(' || *p=='|' ) )
+	    p++;
+	if ( *p == '\0' )
+    break;
+	endp = p;
+	while (!isspace(*endp) && *endp!='\n' && *endp!='\r' && *endp!=')' && *endp!='|')
+	    endp++;
+	end = *endp, *endp = '\0';
+	if ( p<endp && SFFindGID(sf, -1, tmp=eucjp_to_utf8(p)) < 0 )
+	    *dp++ = copy(p);
+	if ( end=='\0' || end==')' )
+    break;
+	else
+	    p = endp + 1;
+    }
+    *dp = NULL;
+    if ( dp==deps )
+return ( NULL );
+    else
+return ( deps );
+}
+
+static int DumpJointExpander(char *defstr, char *filename, char *clwfkdir) {
+    FILE *prog = fopen(filename, "w");
+
+    PrintLispHeader(prog,clwfkdir, true);
+    fprintf(prog, "(format t \"(defjoint gothic XXX ~%%  '\")");
+    fprintf(prog, "(format t \"~A\" (expandkanji '%s))\n", utf8_to_eucjp(defstr));
+    fprintf(prog, "(format t \")\")\n");
+    fprintf(prog, "(quit)\n");
+    fclose(prog);
+
+return ( 0 );
+}
+
+static void ImportFleshToBg(SplineChar *sc, FILE *out) {
+    SplineSet *new, *last;
+    int changed=false;
+	    
+    rewind(out);
+    new = localSplinesFromEntities(EntityInterpretPS(out), 0xffffff, true);
+    if ( sc->parent->order2 ) {
+	SplineSet *o2 = SplineSetsTTFApprox(new);
+	SplinePointListFree(new);
+	new = o2;
+    }
+    if ( new!=NULL ) {
+	sc->parent->onlybitmaps = false;
+	if ( !changed )
+	    SCPreserveState(sc,false);
+	for ( last=new; last->next!=NULL; last=last->next );
+	last->next = sc->layers[ly_back].splines;
+	sc->layers[ly_back].splines = new;
+	changed = true;
+    }
+    if ( changed )
+	SCCharChangedUpdate(sc);
+}
+
+void SFAddOneCharFromSkeleton(SplineFont *sf, int enc, char *defstr) {
+    LispInfo lisp;
+    int pid, status;
+
+fprintf(stderr, "Adding %s to char %d\n", defstr, enc);
+    if ( PrepareLispFile(&lisp)!=0 ||
+	 DumpJointExpander(defstr, lisp.tempname, lisp.dir)!=0 )
+return;
+
+    lisp.out = tmpfile();
+    if ( (pid=fork())==0 ) {
+	/* Child */
+	close(1);
+	dup2(fileno(lisp.out),1);
+	exit(execvp(lisp.prog,lisp.arglist)==-1);	/* If exec fails, then die */
+    } else if ( pid!=-1 ) {
+	waitpid(pid,&status,0);
+	if ( WIFEXITED(status)) {
+	    rewind(lisp.out);
+	    SFReadJointGlyph(sf, enc, lisp.out);
+	}
+    }
+    close(lisp.fd);
+#if 1
+    unlink(lisp.tempname);
+#endif
+}
+
+void SFAddSkelChar(SplineFont *sf, char *defstr) {
+    int nChars = sf->glyphcnt;
+
+    SFAddEncodingSlot( sf, nChars + 1 );
+    SFAddOneCharFromSkeleton(sf, nChars, defstr);
+}
+
+static void SFAddDependents(SplineFont *sf, FILE *out, char *defstr) {
+    char **deps, **dp;
+    int nDeps, enc, defstrIsNameToken;
+
+    rewind(out);
+    deps = dependentGlyphs(sf, out);
+    if (deps != NULL) {
+	enc = sf->glyphcnt + 1;
+	defstrIsNameToken = (strchr(defstr,'(')==NULL);
+	for ( dp = deps, nDeps = 0; *dp != NULL; dp++ )
+	    nDeps++;
+	if ( defstrIsNameToken )
+	    SFAddEncodingSlot( sf, sf->glyphcnt + nDeps + 1 );
+	else
+	    SFAddEncodingSlot( sf, sf->glyphcnt + nDeps );
+	for ( dp = deps; *dp != NULL; dp++ ) {
+	    SFAddOneCharFromSkeleton(sf, enc, *dp);
+/* not yet. because AddOneChar is currently stub. */
+//	    SCCharChangedUpdate(sf->chars[enc++]);
+	}
+#if 0
+	if ( defstrIsNameToken )
+	    SFAddOneCharFromSkeleton(sf, enc, *dp);
+#endif
+    }
+    for (dp = deps; deps != NULL && *dp != NULL; dp++)
+	free(*dp);
+}
+
+void SCAddDependents(SplineChar *sc, char *defstr, char *face) {
+    LispInfo lisp;
+    int pid, status;
+    SplineFont *sf = sc->parent;
+
+    if ( SFFindGID(sf, -1, defstr) >= 0 )
+return;
+    if ( PrepareLispFile(&lisp)!=0 ||
+	 DumpDependsQuery(defstr, lisp.tempname, lisp.dir)!=0 )
+return;
+    
+    lisp.out = tmpfile();
+    if ( (pid=fork())==0 ) {
+	/* Child */
+	close(1);
+	dup2(fileno(lisp.out),1);
+	exit(execvp(lisp.prog,lisp.arglist)==-1);	/* If exec fails, then die */
+    } else if ( pid!=-1 ) {
+	waitpid(pid,&status,0);
+	if ( WIFEXITED(status))
+	    SFAddDependents(sf, lisp.out, defstr);
+    }
+    close(lisp.fd);
+    unlink(lisp.tempname);
+}
+
+void SCFleshSkeleton(SplineChar *sc, char *face, int normkanji) {
+    char *prog, *arglist[30], tempname[1025];
+    int ac, changed=false;
+    int pid, status, fd;
+    FILE *ps;
+    SplineSet *new, *last;
+    char *dir;
+
+    fd = mytempnam(tempname);
+    if ( (dir=FindClwfkDirName()) == NULL ) {
+	gwwv_post_error(_("CLWFK renderer not found"), _("CLWFK renderer not found"));
+return;
+    }
+    if ( (prog=FindLispName())==NULL ) {
+	gwwv_post_error(_("Lisp interpreter (CMUCL) not found"),_("Lisp interpreter (CMUCL) not found"));
+return;
+    }
+    if ( DumpOutlineFlesher(sc, face, tempname, dir, normkanji)!=0 )
+return;
+    
+    ac = 0;
+    arglist[ac++] = prog;
+    /* currently CMUCL only */
+    arglist[ac++] = "-quiet";
+    arglist[ac++] = "-batch";
+    arglist[ac++] = "-load";
+    arglist[ac++] = tempname;
+    arglist[ac++] = NULL;
+
+    ps = tmpfile();
+    if ( (pid=fork())==0 ) {
+	/* Child */
+	close(1);
+	dup2(fileno(ps),1);
+	exit(execvp(prog,arglist)==-1);	/* If exec fails, then die */
+    } else if ( pid!=-1 ) {
+	waitpid(pid,&status,0);
+	if ( WIFEXITED(status)) {
+	    rewind(ps);
+	    new = localSplinesFromEntities(EntityInterpretPS(ps), 0xffffff, true);
+	    if ( sc->parent->order2 ) {
+		SplineSet *o2 = SplineSetsTTFApprox(new);
+		SplinePointListFree(new);
+		new = o2;
+	    }
+	    if ( new!=NULL ) {
+		sc->parent->onlybitmaps = false;
+		if ( !changed )
+		    SCPreserveState(sc,false);
+		for ( last=new; last->next!=NULL; last=last->next );
+		last->next = sc->layers[ly_back].splines;
+		sc->layers[ly_back].splines = new;
+		changed = true;
+	    }
+	}
+    }
+    close(fd);
+    unlink(tempname);
+
+    if ( changed )
+	SCCharChangedUpdate(sc);
+}
+#endif
 
 static void _SCAutoTrace(SplineChar *sc, char **args) {
     ImageList *images;
--- fontforge/charinfo.c.orig	Tue Oct 10 04:49:55 2006
+++ fontforge/charinfo.c	Sun Nov 12 11:41:57 2006
@@ -45,7 +45,11 @@
 } CharInfo;
 
 #define CI_Width	218
+#ifdef FONTFORGE_CONFIG_CLWFK
+#define CI_Height	392
+#else
 #define CI_Height	292
+#endif
 
 #define CID_UName	1001
 #define CID_UValue	1002
@@ -71,6 +75,20 @@
 #define CID_Copy	1024
 #define CID_Paste	1025
 
+#ifdef FONTFORGE_CONFIG_CLWFK
+#define CID_PartName	1030
+#define CID_JointDef	1031
+#define CID_TateHeight	1032
+#define CID_YokoWidth	1033
+#define CID_PrimWidth	1034
+#define CID_Xunit	1035
+#define CID_Yunit	1036
+#define CID_PrimCenter	1037
+#define CID_Up		1038
+#define CID_Down	1039
+#define CID_Hook	1040
+#endif
+
 #define CID_PST		1111
 #define CID_Tag		1112
 #define CID_Contents	1113
@@ -4562,7 +4580,12 @@
 
     if ( uc_strcmp(name,".notdef")==0 )		/* This name is a special case and doesn't follow conventions */
 return( true );
+#ifdef FONTFORGE_CONFIG_CLWFK
+    /* this should be if 'allow_utf8_glyphnames' is enabled */
+    if ( u_strlen(name)>127 ) {
+#else
     if ( u_strlen(name)>31 ) {
+#endif
 	gwwv_post_error(_("Bad Name"),_("Glyph names are limitted to 31 characters"));
 return( false );
     } else if ( *name=='\0' ) {
@@ -4629,7 +4652,15 @@
     FontView *fvs;
     int err = false;
     int tex_height, tex_depth, tex_sub, tex_super;
+#ifdef FONTFORGE_CONFIG_CLWFK
+    SkelParams clwfk;
+#if 00
+    char *glyphname;
+#endif
+    const unichar_t *jointdef;
 
+    memset(&clwfk,'\0',sizeof(SkelParams));
+#endif
     val = ParseUValue(ci->gw,CID_UValue,true,ci->sc->parent);
     if ( val==-2 )
 return( false );
@@ -4641,6 +4672,35 @@
 return( false );
     if ( !CI_ProcessPosSubs(ci))
 return( false );
+#ifdef FONTFORGE_CONFIG_CLWFK
+#if 00
+    glyphname = u2utf8_copy(_GGadgetGetTitle(GWidgetGetControl(ci->gw,CID_PartName)));
+    if ( glyphname==NULL || ci->sc->name==NULL || strcmp(glyphname, ci->sc->name)!=0 ) {
+       clwfk.glyphname = copy(glyphname);
+       free( ci->sc->name );
+    } else
+       clwfk.glyphname = ci->sc->clwfk.glyphname;
+#endif
+
+    jointdef = _GGadgetGetTitle(GWidgetGetControl(ci->gw,CID_JointDef));
+    if ( jointdef==NULL || ci->sc->clwfk.jointdef==NULL ||
+	 u_strcmp(jointdef, ci->sc->clwfk.jointdef) != 0 ) {
+       clwfk.jointdef = u_copy(jointdef);
+       free ( ci->sc->clwfk.jointdef );
+    } else
+       clwfk.jointdef = ci->sc->clwfk.jointdef;
+
+    clwfk.tateheight = GetReal8(ci->gw,CID_TateHeight,_("tateheight:"),&err);
+    clwfk.yokowidth  = GetReal8(ci->gw,CID_YokoWidth ,_("yokowidth:"), &err);
+    clwfk.xunit      = GetReal8(ci->gw,CID_Xunit,     _("xunit:"),     &err);
+    clwfk.yunit      = GetReal8(ci->gw,CID_Yunit,     _("ynit:"),      &err);
+    clwfk.center     = GetReal8(ci->gw,CID_PrimCenter,_("center"),     &err);
+    clwfk.width      = GetReal8(ci->gw,CID_PrimWidth, _("width:"),     &err);
+    clwfk.up         = GetReal8(ci->gw,CID_Up,        _("up"),         &err);
+    clwfk.down       = GetReal8(ci->gw,CID_Down,      _("down"),       &err);
+    if ( err )
+return( false );
+#endif
     nm = _GGadgetGetTitle(GWidgetGetControl(ci->gw,CID_UName));
     if ( !CI_NameCheck(nm) )
 return( false );
@@ -4672,6 +4732,10 @@
 	ci->sc->tex_depth  = tex_depth;
 	ci->sc->tex_sub_pos   = tex_sub;
 	ci->sc->tex_super_pos = tex_super;
+#ifdef FONTFORGE_CONFIG_CLWFK
+	ci->sc->clwfk = clwfk;
+	GDrawRequestExpose(ci->sc->parent->fv->v,NULL,false);
+#endif
     }
     if ( ret )
 	ci->sc->parent->changed = true;
@@ -5734,6 +5798,70 @@
 	buffer[0] = '\0';
     uc_strcpy(ubuf,buffer);
     GGadgetSetTitle(GWidgetGetControl(ci->gw,CID_TeX_Super),ubuf);
+
+#ifdef FONTFORGE_CONFIG_CLWFK
+    if ( sc->name != NULL )
+        GGadgetSetTitle8(GWidgetGetControl(ci->gw,CID_PartName),sc->name);
+
+    if ( sc->clwfk.jointdef != NULL )
+        GGadgetSetTitle(GWidgetGetControl(ci->gw,CID_JointDef),sc->clwfk.jointdef);
+
+    if ( sc->clwfk.tateheight != 0.0 )
+        sprintf(buffer,"%.1f", sc->clwfk.tateheight);
+    else
+	buffer[0] = '\0';
+    uc_strcpy(ubuf,buffer);
+    GGadgetSetTitle(GWidgetGetControl(ci->gw,CID_TateHeight),ubuf);
+    
+    if ( sc->clwfk.yokowidth != 0.0 )
+        sprintf(buffer,"%.1f", sc->clwfk.yokowidth);
+    else
+	buffer[0] = '\0';
+    uc_strcpy(ubuf,buffer);
+    GGadgetSetTitle(GWidgetGetControl(ci->gw,CID_YokoWidth),ubuf);
+    
+    if ( sc->clwfk.xunit != 0.0 )
+        sprintf(buffer,"%.1f", sc->clwfk.xunit);
+    else
+	buffer[0] = '\0';
+    uc_strcpy(ubuf,buffer);
+    GGadgetSetTitle(GWidgetGetControl(ci->gw,CID_Xunit),ubuf);
+
+    if ( sc->clwfk.yunit != 0.0 )
+        sprintf(buffer,"%.1f", sc->clwfk.yunit);
+    else
+	buffer[0] = '\0';
+    uc_strcpy(ubuf,buffer);
+    GGadgetSetTitle(GWidgetGetControl(ci->gw,CID_Yunit),ubuf);
+
+    if ( sc->clwfk.center != 0.0 )
+        sprintf(buffer,"%.1f", sc->clwfk.center);
+    else
+	buffer[0] = '\0';
+    uc_strcpy(ubuf,buffer);
+    GGadgetSetTitle(GWidgetGetControl(ci->gw,CID_PrimCenter),ubuf);
+
+    if ( sc->clwfk.width != 0.0 )
+        sprintf(buffer,"%.1f", sc->clwfk.width);
+    else
+	buffer[0] = '\0';
+    uc_strcpy(ubuf,buffer);
+    GGadgetSetTitle(GWidgetGetControl(ci->gw,CID_PrimWidth),ubuf);
+
+    if ( sc->clwfk.up != 0.0 )
+        sprintf(buffer,"%.1f", sc->clwfk.up);
+    else
+	buffer[0] = '\0';
+    uc_strcpy(ubuf,buffer);
+    GGadgetSetTitle(GWidgetGetControl(ci->gw,CID_Up),ubuf);
+
+    if ( sc->clwfk.down != 0.0 )
+        sprintf(buffer,"%.1f", sc->clwfk.down);
+    else
+	buffer[0] = '\0';
+    uc_strcpy(ubuf,buffer);
+    GGadgetSetTitle(GWidgetGetControl(ci->gw,CID_Down),ubuf);
+#endif
 }
 
 static int CI_NextPrev(GGadget *g, GEvent *e) {
@@ -5819,6 +5947,10 @@
     GWindowAttrs wattrs;
     GGadgetCreateData ugcd[12], cgcd[6], psgcd[7][7], cogcd[3], mgcd[9], tgcd[10];
     GTextInfo ulabel[12], clabel[6], pslabel[7][6], colabel[3], mlabel[9], tlabel[10];
+#ifdef FONTFORGE_CONFIG_CLWFK
+    GGadgetCreateData clgcd[17];
+    GTextInfo cllabel[17];
+#endif
     GGadgetCreateData mbox[4], *mvarray[7], *mharray1[7], *mharray2[8];
     GGadgetCreateData ubox[3], *uhvarray[19], *uharray[6];
     GGadgetCreateData cbox[3], *cvarray[5], *charray[4];
@@ -5890,7 +6022,11 @@
 	uhvarray[0] = &ugcd[0];
 
 	ugcd[1].gd.pos.x = 85; ugcd[1].gd.pos.y = 5;
+#ifdef FONTFORGE_CONFIG_CLWFK
+	ugcd[1].gd.flags = gg_enabled|gg_visible|gg_text_xim;
+#else
 	ugcd[1].gd.flags = gg_enabled|gg_visible;
+#endif
 	ugcd[1].gd.mnemonic = 'N';
 	ugcd[1].gd.cid = CID_UName;
 	ugcd[1].creator = GListFieldCreate;
@@ -6153,6 +6289,109 @@
 	cobox[0].gd.u.boxelements = covarray;
 	cobox[0].creator = GVBoxCreate;
 	
+#ifdef FONTFORGE_CONFIG_CLWFK
+	memset(&clgcd,0,sizeof(clgcd));
+	memset(&cllabel,0,sizeof(cllabel));
+
+/* USE static void CI_SetNameList(CharInfo *ci,int val) */
+	cllabel[0].text = (unichar_t *) _("Part Name:");
+	cllabel[0].text_is_1byte = true;
+	clgcd[0].gd.label = &cllabel[0];
+	clgcd[0].gd.pos.x = 5; clgcd[0].gd.pos.y = 5+4;
+	clgcd[0].gd.flags = gg_enabled|gg_visible|gg_utf8_popup;
+	clgcd[0].gd.popup_msg = (unichar_t *) _("This dialog sets information about a CLWFK primitive");
+	clgcd[0].creator = GLabelCreate;
+
+	clgcd[1].gd.pos.x = 65; clgcd[1].gd.pos.y = 5; clgcd[1].gd.pos.width = 130; clgcd[1].gd.pos.height = 36;
+	clgcd[1].gd.flags = gg_enabled|gg_visible|gg_text_xim|gg_textarea_wrap;
+	clgcd[1].gd.cid = CID_PartName;
+	clgcd[1].creator = GTextAreaCreate;
+
+	cllabel[2].text = (unichar_t *) _("Joint Def:");
+	cllabel[2].text_is_1byte = true;
+	clgcd[2].gd.label = &cllabel[2];
+	clgcd[2].gd.pos.x = 5; clgcd[2].gd.pos.y = 45+4; 
+	clgcd[2].gd.flags = gg_enabled|gg_visible|gg_utf8_popup;
+	clgcd[2].gd.popup_msg = (unichar_t *) _("Origianal definition of combinied components");
+	clgcd[2].creator = GLabelCreate;
+
+	clgcd[3].gd.pos.x = 65; clgcd[3].gd.pos.y = 45; clgcd[3].gd.pos.width = 130; clgcd[3].gd.pos.height = 54;
+	clgcd[3].gd.flags = gg_enabled|gg_visible|gg_text_xim|gg_textarea_wrap;
+	clgcd[3].gd.cid = CID_JointDef;
+	clgcd[3].creator = GTextAreaCreate;
+
+	cllabel[4].text = (unichar_t *) _("TateH/YokoW:");
+	cllabel[4].text_is_1byte = true;
+	clgcd[4].gd.label = &cllabel[4];
+	clgcd[4].gd.pos.x = 5; clgcd[4].gd.pos.y = 103+4; 
+	clgcd[4].gd.flags = gg_enabled|gg_visible|gg_utf8_popup;
+	clgcd[4].gd.popup_msg = (unichar_t *) _("tateheight/yokowidth:");
+	clgcd[4].creator = GLabelCreate;
+
+	clgcd[5].gd.pos.x = 85; clgcd[5].gd.pos.y = 103; clgcd[5].gd.pos.width = 50;
+ 	clgcd[5].gd.flags = gg_enabled|gg_visible;
+	clgcd[5].gd.cid = CID_TateHeight;
+	clgcd[5].creator = GTextFieldCreate;
+
+	clgcd[6].gd.pos.x = 140; clgcd[6].gd.pos.y = 103; clgcd[6].gd.pos.width = 50;
+	clgcd[6].gd.flags = gg_enabled|gg_visible|gg_utf8_popup;
+	clgcd[6].gd.cid = CID_YokoWidth;
+	clgcd[6].creator = GTextFieldCreate;
+
+	cllabel[7].text = (unichar_t *) _("width/center:");
+	cllabel[7].text_is_1byte = true;
+	clgcd[7].gd.label = &cllabel[7];
+	clgcd[7].gd.pos.x = 5; clgcd[7].gd.pos.y = 128+4; 
+	clgcd[7].gd.flags = gg_enabled|gg_visible|gg_utf8_popup;
+	clgcd[7].gd.popup_msg = clgcd[0].gd.popup_msg;
+	clgcd[7].creator = GLabelCreate;
+
+	clgcd[8].gd.pos.x = 85; clgcd[8].gd.pos.y = 128; clgcd[8].gd.pos.width = 50;
+ 	clgcd[8].gd.flags = gg_enabled|gg_visible;
+	clgcd[8].gd.cid = CID_PrimWidth;
+	clgcd[8].creator = GTextFieldCreate;
+
+	clgcd[9].gd.pos.x = 140; clgcd[9].gd.pos.y = 128; clgcd[9].gd.pos.width = 50;
+	clgcd[9].gd.flags = gg_enabled|gg_visible;
+	clgcd[9].gd.cid = CID_PrimCenter;
+ 	clgcd[9].creator = GTextFieldCreate;
+
+	cllabel[10].text = (unichar_t *) _("xunit/yunit:");
+	cllabel[10].text_is_1byte = true;
+	clgcd[10].gd.label = &cllabel[10];
+	clgcd[10].gd.pos.x = 5; clgcd[10].gd.pos.y = 153+4; 
+ 	clgcd[10].gd.flags = gg_enabled|gg_visible|gg_utf8_popup;
+	clgcd[10].gd.popup_msg = clgcd[0].gd.popup_msg;
+	clgcd[10].creator = GLabelCreate;
+ 
+	clgcd[11].gd.pos.x = 85; clgcd[11].gd.pos.y = 153; clgcd[11].gd.pos.width = 50;
+ 	clgcd[11].gd.flags = gg_enabled|gg_visible;
+	clgcd[11].gd.cid = CID_Xunit;
+	clgcd[11].creator = GTextFieldCreate;
+ 
+	clgcd[12].gd.pos.x = 85; clgcd[12].gd.pos.y = 124; clgcd[12].gd.pos.width = 50;
+ 	clgcd[12].gd.flags = gg_enabled|gg_visible;
+	clgcd[12].gd.cid = CID_Yunit;
+ 	clgcd[12].creator = GTextFieldCreate;
+ 
+	cllabel[13].text = (unichar_t *) _("updown:");
+	cllabel[13].text_is_1byte = true;
+	clgcd[13].gd.label = &cllabel[13];
+	clgcd[13].gd.pos.x = 5; clgcd[13].gd.pos.y = 178+4; 
+ 	clgcd[13].gd.flags = gg_enabled|gg_visible|gg_utf8_popup;
+	clgcd[13].gd.popup_msg = clgcd[0].gd.popup_msg;
+	clgcd[13].creator = GLabelCreate;
+
+	clgcd[14].gd.pos.x = 85; clgcd[14].gd.pos.y = 178; clgcd[14].gd.pos.width = 50;
+	clgcd[14].gd.flags = gg_enabled|gg_visible;
+	clgcd[14].gd.cid = CID_Up;
+	clgcd[14].creator = GTextFieldCreate;
+
+	clgcd[15].gd.pos.x = 140; clgcd[15].gd.pos.y = 178; clgcd[15].gd.pos.width = 50;
+	clgcd[15].gd.flags = gg_enabled|gg_visible;
+	clgcd[15].gd.cid = CID_Down;
+	clgcd[15].creator = GTextFieldCreate;
+#endif
 
 
 	memset(&tgcd,0,sizeof(tgcd));
@@ -6294,6 +6533,12 @@
 	aspects[i].text = (unichar_t *) U_("ΤεΧ");		/* TeX */
 	aspects[i].text_is_1byte = true;
 	aspects[i++].gcd = tbox;
+
+#ifdef FONTFORGE_CONFIG_CLWFK
+	aspects[i].text = (unichar_t *) _("CLWFK");
+	aspects[i].text_is_1byte = true;
+	aspects[i++].gcd = clgcd;
+#endif
 
 	mgcd[0].gd.pos.x = 4; mgcd[0].gd.pos.y = 6;
 	mgcd[0].gd.u.tabs = aspects;
--- fontforge/charview.c.orig	Thu Oct 19 12:59:27 2006
+++ fontforge/charview.c	Sun Nov 12 11:44:26 2006
@@ -111,6 +111,12 @@
 static Color backimagecol = 0x707070;
 static Color fillcol = 0x707070;
 static Color tracecol = 0x008000;
+#ifdef FONTFORGE_CONFIG_CLWFK
+static Color linkpointcol = 0x40a040;
+static Color lockedpointcol = 0x2020ff;
+static Color lockedfirstpointcol = 0x6090e0;
+static Color lockedselectedpointcol = 0x30ff40;
+#endif
 
 static int cvcolsinited = false;
 
@@ -460,12 +466,20 @@
     char buf[12]; unichar_t ubuf[12];
     int isfake;
 
+#ifdef FONTFORGE_CONFIG_CLWFK
+    if ( sp->locked )
+	col = sp==spl->first ? lockedfirstpointcol : lockedpointcol;
+#endif
     if ( cv->markextrema && !sp->nonextcp && !sp->noprevcp &&
 	    ((sp->nextcp.x==sp->me.x && sp->prevcp.x==sp->me.x) ||
 	     (sp->nextcp.y==sp->me.y && sp->prevcp.y==sp->me.y)) )
 	 col = extremepointcol;
     if ( sp->selected )
 	 col = selectedpointcol;
+#ifdef FONTFORGE_CONFIG_CLWFK
+    if ( sp->selected && sp->locked )
+         col = lockedselectedpointcol;
+#endif
 
     x =  cv->xoff + rint(sp->me.x*cv->scale);
     y = -cv->yoff + cv->height - rint(sp->me.y*cv->scale);
@@ -568,11 +582,25 @@
 	    GDrawDrawElipse(pixmap,&r,col);
 	else
 	    GDrawFillElipse(pixmap,&r,col);
+#ifdef FONTFORGE_CONFIG_CLWFK
+	if ( sp->islinkpt ) {
+	    r.x -= 4; r.y -= 4; r.width += 7; r.height += 7;
+	    GDrawSetLineWidth(pixmap,1);
+	    GDrawDrawElipse(pixmap,&r,linkpointcol);
+	}
+#endif
     } else if ( sp->pointtype==pt_corner ) {
 	if ( sp->selected || isfake )
 	    GDrawDrawRect(pixmap,&r,col);
 	else
 	    GDrawFillRect(pixmap,&r,col);
+#ifdef FONTFORGE_CONFIG_CLWFK
+	if ( sp->islinkpt ) {
+	    r.x -= 4; r.y -= 4; r.width += 7; r.height += 7;
+	    GDrawSetLineWidth(pixmap,1);
+	    GDrawDrawElipse(pixmap,&r,linkpointcol);
+	}
+#endif
     } else {
 	GPoint gp[5];
 	int dir;
@@ -619,6 +647,13 @@
 	    GDrawDrawPoly(pixmap,gp,4,col);
 	else
 	    GDrawFillPoly(pixmap,gp,4,col);
+#ifdef FONTFORGE_CONFIG_CLWFK
+	if ( sp->islinkpt ) {
+	    r.x -= 4; r.y -= 4; r.width += 7; r.height += 7;
+	    GDrawSetLineWidth(pixmap,1);
+	    GDrawDrawElipse(pixmap,&r,linkpointcol);
+	}
+#endif
     }
     GDrawSetLineWidth(pixmap,0);
     if ( (cv->showpointnumbers || cv->show_ft_results|| cv->dv ) && sp->ttfindex!=0xffff ) {
@@ -628,6 +663,12 @@
 	    sprintf( buf,"%d", sp->ttfindex );
 	GDrawDrawText8(pixmap,x,y-6,buf,-1,NULL,col);
     }
+#ifdef FONTFORGE_CONFIG_CLWFK
+    if ( cv->sc->parent->strokedfont >= 1 && sp==spl->first ) {
+	uc_strcpy(ubuf,stroketypes[spl->stroketype]);
+	GDrawDrawText(pixmap,x,y-6,ubuf,-1,NULL,col);
+    }
+#endif
     if ( !onlynumber ) {
 	if ((( sp->roundx || sp->roundy ) &&
 		 (((cv->showrounds&1) && cv->scale>=.3) || (cv->showrounds&2))) ||
@@ -2027,6 +2068,22 @@
 static void SVMenuSimplifyMore(GWindow gw,struct gmenuitem *mi,GEvent *e);
 #endif
 
+#ifdef FONTFORGE_CONFIG_CLWFK
+/* copied from SSIsSelected() in splineoverlap.c */
+static int SplIsSelected(SplinePointList *spl) {
+    SplinePoint *sp;
+
+    for ( sp=spl->first; ; ) {
+        if ( sp->selected )
+return( true );
+        if ( sp->next==NULL )
+return( false );
+        sp = sp->next->to;
+        if ( sp==spl->first )
+return( false );
+    }
+}
+#endif
 
 static void CVFakeMove(CharView *cv, GEvent *event) {
     GEvent e;
@@ -2128,6 +2185,15 @@
 #endif
 	if ( pos>=0 && pos<cv->fv->map->enccount )
 	    CVChangeChar(cv,pos);
+#ifdef FONTFORGE_CONFIG_CLWFK
+    } else if ( event->u.chr.keysym == '$' &&
+		(event->u.chr.state&(ksm_control))==(ksm_control)) {
+	SCClearBackground(cv->sc);
+	SCFleshSkeleton(cv->sc, "mincho", CVShows.normkanji);
+    } else if ( event->u.chr.keysym == '%' && (event->u.chr.state&ksm_control) ) {
+	SCClearBackground(cv->sc);
+	SCFleshSkeleton(cv->sc, "gothic", CVShows.normkanji);
+#endif
     } else if ( event->u.chr.keysym == GK_Left ||
 	    event->u.chr.keysym == GK_Up ||
 	    event->u.chr.keysym == GK_Right ||
@@ -2151,6 +2217,37 @@
 	    dy = -1;
 	  break;
 	}
+#ifdef FONTFORGE_CONFIG_CLWFK
+	if ( event->u.chr.state & ksm_control && 
+	     event->u.chr.state & ksm_shift &&
+	     cv->sc->parent->strokewidth > 0 ) {
+	    SplinePointList *spl;
+	    int dw;
+	    switch ( event->u.chr.keysym ) {
+	    case GK_Left: case GK_KP_Left:
+	    case GK_Up: case GK_KP_Up:
+		dw = 1;
+	    break;
+	    case GK_Right: case GK_KP_Right:
+	    case GK_Down: case GK_KP_Down:
+		dw = -1;
+	    break;
+	    }
+	    for ( spl=cv->sc->layers[ly_fore].splines; spl!=NULL; spl=spl->next ) {
+		if ( SplIsSelected(spl) ) {
+		    if ( spl->width==0 ) 
+			spl->width = cv->sc->parent->strokewidth;
+		    spl->width += dw;
+		    if ( spl->width < 0 )
+			spl->width = 0;
+		    if ( spl->stroketype >= sk_kamae )
+			spl->width = 0;
+		}
+	    }
+	    SCRegenFills(cv->sc);
+	    CVCharChangedUpdate(cv);
+	} else
+#endif
 	if ( event->u.chr.state & (ksm_control|ksm_capslock) ) {
 	    struct sbevent sb;
 	    sb.type = dy>0 || dx<0 ? et_sb_halfup : et_sb_halfdown;
@@ -4306,6 +4403,11 @@
 #define MID_Former	2026
 #define MID_MarkPointsOfInflection	2027
 #define MID_ShowCPInfo	2028
+#ifdef FONTFORGE_CONFIG_CLWFK
+#define MID_ShowMinchoOutline	2031
+#define MID_ShowGothicOutline	2032
+#define MID_NormKanji		2033
+#endif
 #define MID_Cut		2101
 #define MID_Copy	2102
 #define MID_Paste	2103
@@ -4387,6 +4489,11 @@
 #define MID_NoImplicitPt	2308
 #define MID_InsertPtOnSplineAt	2309
 #define MID_AddAnchor	2310
+#ifdef FONTFORGE_CONFIG_CLWFK
+#define MID_ToggleLocked	2320
+#define MID_ToggleLinkPoint 2321
+#define MID_StrokeInfo 2322
+#endif
 #define MID_AutoHint	2400
 #define MID_ClearHStem	2401
 #define MID_ClearVStem	2402
@@ -4750,6 +4857,32 @@
     GDrawRequestExpose(cv->v,NULL,false);
 }
 
+#ifdef FONTFORGE_CONFIG_CLWFK
+void SCClearBackground(SplineChar *);
+
+static void CVMenuShowMinchoOutline(GWindow gw,struct gmenuitem *mi,GEvent *e) {
+    CharView *cv = (CharView *) GDrawGetUserData(gw);
+
+    SCClearBackground(cv->sc);
+    SCFleshSkeleton(cv->sc, "mincho", CVShows.normkanji);
+    GDrawRequestExpose(cv->v,NULL,false);
+}
+
+static void CVMenuShowGothicOutline(GWindow gw,struct gmenuitem *mi,GEvent *e) {
+    CharView *cv = (CharView *) GDrawGetUserData(gw);
+
+    SCClearBackground(cv->sc);
+    SCFleshSkeleton(cv->sc, "gothic", CVShows.normkanji);
+    GDrawRequestExpose(cv->v,NULL,false);
+}
+
+static void CVToggleNormKanji(GWindow gw,struct gmenuitem *mi,GEvent *e) {
+    CharView *cv = (CharView *) GDrawGetUserData(gw);
+
+    CVShows.normkanji = cv->normkanji = !cv->normkanji;
+}
+#endif
+
 static void CVMenuShowGridFit(GWindow gw,struct gmenuitem *mi,GEvent *e) {
     CharView *cv = (CharView *) GDrawGetUserData(gw);
 
@@ -5543,6 +5676,293 @@
     }
 }
 
+#ifdef FONTFORGE_CONFIG_CLWFK
+static void _CVMenuToggleLocked(CharView *cv,struct gmenuitem *mi) {
+    int locked = -2;
+    SplinePointList *spl;
+    Spline *spline, *first;
+
+    CVPreserveState(cv);
+    for ( spl = cv->layerheads[cv->drawmode]->splines; spl!=NULL ; spl = spl->next ) {
+	first = NULL;
+	if ( spl->first->selected ) {
+	    if ( locked==-2 ) locked=spl->first->locked;
+	    else if ( spl->first->locked!=locked ) locked=-1;
+	}
+	for ( spline=spl->first->next; spline!=NULL && spline!=first ; spline = spline->to->next ) {
+	    if ( spline->to->selected ) {
+		if ( locked==-2 ) locked=spline->to->locked;
+		else if ( spline->to->locked!=locked ) locked=-1;
+	    }
+	    if ( first==NULL ) first = spline;
+	}
+    }
+    if (locked==-1) locked = 0;
+    for ( spl = cv->layerheads[cv->drawmode]->splines; spl!=NULL ; spl = spl->next ) {
+	first = NULL;
+	if ( spl->first->selected )
+	    spl->first->locked = !locked;
+	for ( spline=spl->first->next; spline!=NULL && spline!=first ; spline = spline->to->next ) {
+	    if ( spline->to->selected )
+		spline->to->locked = !locked;
+	    if ( first==NULL ) first = spline;
+	}
+    }
+    CVCharChangedUpdate(cv);
+}
+
+static void CVMenuToggleLocked(GWindow gw,struct gmenuitem *mi,GEvent *e) {
+    CharView *cv = (CharView *) GDrawGetUserData(gw);
+    _CVMenuToggleLocked(cv,mi);
+}
+
+static void _CVMenuToggleLinkPoint(CharView *cv,struct gmenuitem *mi) {
+    int islinkpt = -2;
+    SplinePointList *spl;
+    Spline *spline, *first;
+
+    CVPreserveState(cv);
+    for ( spl = cv->layerheads[cv->drawmode]->splines; spl!=NULL ; spl = spl->next ) {
+	first = NULL;
+	if ( spl->first->selected ) {
+	    if ( islinkpt==-2 ) islinkpt=spl->first->islinkpt;
+	    else if ( spl->first->islinkpt!=islinkpt ) islinkpt=-1;
+	}
+	for ( spline=spl->first->next; spline!=NULL && spline!=first ; spline = spline->to->next ) {
+	    if ( spline->to->selected ) {
+		if ( islinkpt==-2 ) islinkpt=spline->to->islinkpt;
+		else if ( spline->to->islinkpt!=islinkpt ) islinkpt=-1;
+	    }
+	    if ( first==NULL ) first = spline;
+	}
+    }
+    if (islinkpt==-1) islinkpt = 0;
+    for ( spl = cv->layerheads[cv->drawmode]->splines; spl!=NULL ; spl = spl->next ) {
+	first = NULL;
+	if ( spl->first->selected )
+	    spl->first->islinkpt = !islinkpt;
+	for ( spline=spl->first->next; spline!=NULL && spline!=first ; spline = spline->to->next ) {
+	    if ( spline->to->selected )
+		spline->to->islinkpt = !islinkpt;
+	    if ( first==NULL ) first = spline;
+	}
+    }
+    CVCharChangedUpdate(cv);
+}
+
+static void CVMenuToggleLinkPoint(GWindow gw,struct gmenuitem *mi,GEvent *e) {
+    CharView *cv = (CharView *) GDrawGetUserData(gw);
+    _CVMenuToggleLinkPoint(cv,mi);
+}
+
+#define CID_Width 1000
+#define CID_StrokeType 1001
+
+GTextInfo stroketypelist[num_enum_stroke+2] = {
+  { (unichar_t *) "ten", NULL, 0, 0, (void *)sk_ten, NULL, 0, 0, 0, 0, 0, 0, 1},
+  { (unichar_t *) "tate", NULL, 0, 0, (void *)sk_tate, NULL, 0, 0, 0, 0, 0, 0, 1},
+  { (unichar_t *) "yoko", NULL, 0, 0, (void *)sk_yoko, NULL, 0, 0, 0, 0, 0, 0, 1},
+  { (unichar_t *) "migiue", NULL, 0, 0, (void *)sk_migiue, NULL, 0, 0, 0, 0, 0, 0, 1},
+  { (unichar_t *) "hidari", NULL, 0, 0, (void *)sk_hidari, NULL, 0, 0, 0, 0, 0, 0, 1},
+  { (unichar_t *) "tatehidari", NULL, 0, 0, (void *)sk_tatehidari, NULL, 0, 0, 0, 0, 0, 0, 1},
+  { (unichar_t *) "migi", NULL, 0, 0, (void *)sk_migi, NULL, 0, 0, 0, 0, 0, 0, 1},
+  { (unichar_t *) "kozato", NULL, 0, 0, (void *)sk_kozato, NULL, 0, 0, 0, 0, 0, 0, 1},
+  { (unichar_t *) "tatehane", NULL, 0, 0, (void *)sk_tatehane, NULL, 0, 0, 0, 0, 0, 0, 1},
+  { (unichar_t *) "tsukurihane", NULL, 0, 0, (void *)sk_tsukurihane, NULL, 0, 0, 0, 0, 0, 0, 1},
+  { (unichar_t *) "sanzui", NULL, 0, 0, (void *)sk_sanzui, NULL, 0, 0, 0, 0, 0, 0, 1},
+  { (unichar_t *) "kokoro", NULL, 0, 0, (void *)sk_kokoro, NULL, 0, 0, 0, 0, 0, 0, 1},
+  { (unichar_t *) "tasuki", NULL, 0, 0, (void *)sk_tasuki, NULL, 0, 0, 0, 0, 0, 0, 1},
+  { (unichar_t *) "shin-nyuu", NULL, 0, 0, (void *)sk_shin_nyuu, NULL, 0, 0, 0, 0, 0, 0, 1},
+  { (unichar_t *) "magaritate", NULL, 0, 0, (void *)sk_magaritate, NULL, 0, 0, 0, 0, 0, 0, 1},
+  { (unichar_t *) "kagi", NULL, 0, 0, (void *)sk_kagi, NULL, 0, 0, 0, 0, 0, 0, 1},
+  { (unichar_t *) "hira_long", NULL, 0, 0, (void *)sk_hira_long, NULL, 0, 0, 0, 0, 0, 0, 1},
+  { (unichar_t *) "kamae", NULL, 0, 0, (void *)sk_kamae, NULL, 0, 0, 0, 0, 0, 0, 1},
+  { (unichar_t *) "kamae1", NULL, 0, 0, (void *)sk_kamae1, NULL, 0, 0, 0, 0, 0, 0, 1},
+  { (unichar_t *) "kamae2", NULL, 0, 0, (void *)sk_kamae2, NULL, 0, 0, 0, 0, 0, 0, 1},
+  { (unichar_t *) "nyou", NULL, 0, 0, (void *)sk_nyou, NULL, 0, 0, 0, 0, 0, 0, 1},
+  { (unichar_t *) "tare", NULL, 0, 0, (void *)sk_tare, NULL, 0, 0, 0, 0, 0, 0, 1},
+  { (unichar_t *) "----", NULL, 0, 0, (void *)num_enum_stroke, NULL, 0, 0, 0, 0, 0, 0, 1},
+  { NULL }
+};
+
+struct sgid {
+    unsigned int done: 1;
+    struct charview *cv;
+    SplinePointList *spl;
+    GWindow gw;
+};
+
+static int SGID_OK(GGadget *g, GEvent *e) {
+    int err = false;
+
+    if ( e->type==et_controlevent && e->u.control.subtype == et_buttonactivate ) {
+	SplinePointList *spl;
+	int stroketype;
+	real width;
+  	struct sgid *sgid = GDrawGetUserData(GGadgetGetWindow(g)); 
+
+ 	width = GetReal8(sgid->gw,CID_Width,_("Width"), &err);
+ 	stroketype = (int) (GGadgetGetListItemSelected(GWidgetGetControl(sgid->gw,CID_StrokeType))->userdata);
+ 
+ 	for (spl = sgid->spl; spl != NULL; spl = spl->next) {
+	    SplinePointList *found = NULL;
+	    Spline *spline;
+ 
+	    if ( spl->first->selected )
+		found = spl;
+	    for ( spline=spl->first->next; spline!=NULL; spline=spline->to->next ) {
+		if ( spline->to == spl->first )
+		    /* returned to first spline point */
+	    break;
+		if ( spline->to->selected )
+		    found = spl;
+	    }
+	    if ( found!=NULL ) {
+		spl->width = width;
+		if ( stroketype < num_enum_stroke )
+		    spl->stroketype = stroketype;
+	    }
+ 	}
+	sgid->cv->sc->parent->last_stroketype = sgid->spl->stroketype;
+	sgid->done = true;
+    }
+return( true );
+}
+
+static int SGID_Cancel(GGadget *g, GEvent *e) {
+    if ( e->type==et_controlevent && e->u.control.subtype == et_buttonactivate ) {
+	struct sgid *sgid = GDrawGetUserData(GGadgetGetWindow(g));
+	sgid->done = true;
+    }
+return( true );
+}
+
+static int sgid_e_h(GWindow gw, GEvent *event) {
+  if ( event->type==et_close ) {
+      struct sgid *sgid = GDrawGetUserData(gw);
+      sgid->done = true;
+  } else if ( event->type == et_char ) {
+return( false );
+  } else if ( event->type == et_map ) {
+    /* Above palettes */
+        GDrawRaise(gw);
+  }
+return( true );
+}
+
+void StrokeGetInfo(CharView *cv, SplinePointList *spl, int selected_num) {
+    GWindow gw;
+    GWindowAttrs wattrs;
+    GGadgetCreateData gcd[9];
+    GTextInfo label[9];
+    GRect pos;
+    char buffer[20];
+    int i, j;
+    struct sgid sgid;
+
+    sgid.done = false;
+    sgid.cv = cv;
+    sgid.spl = spl;
+
+    memset(&wattrs,0,sizeof(wattrs));
+    wattrs.mask = wam_events|wam_cursor|wam_utf8_wtitle|wam_undercursor|wam_isdlg|wam_restrict;
+    wattrs.event_masks = ~(1<<et_charup);
+    wattrs.restrict_input_to_me = 1;
+    wattrs.undercursor = 1;
+    wattrs.cursor = ct_pointer;
+    wattrs.utf8_window_title = _("Stroke Info");
+    wattrs.is_dlg = true;
+    pos.x = pos.y = 0;
+    pos.width = GGadgetScale(GDrawPointsToPixels(NULL,200));
+    pos.height = GDrawPointsToPixels(NULL,105);
+    sgid.gw = gw = GDrawCreateTopWindow(NULL,&pos,sgid_e_h,&sgid,&wattrs);
+    
+    memset(&label,0,sizeof(label));
+    memset(&gcd,0,sizeof(gcd));
+
+    i = 0;
+    label[i].text = (unichar_t *)_("Stroke Type:");
+    label[i].text_is_1byte = true;
+    gcd[i].gd.label = &label[i];
+    gcd[i].gd.pos.x = 7; gcd[i].gd.pos.y = 7+3+5; 
+    gcd[i].gd.flags = gg_enabled|gg_visible;
+    gcd[i++].creator = GLabelCreate;
+
+    gcd[i].gd.pos.x = 80; gcd[i].gd.pos.y = gcd[i-1].gd.pos.y-5; gcd[i].gd.pos.width = 100;
+    if (selected_num <= 1)
+	gcd[i].gd.flags = gg_enabled|gg_visible;
+    else
+	gcd[1].gd.flags = gg_visible;
+    gcd[i].gd.u.list = stroketypelist;
+    gcd[i].gd.cid = CID_StrokeType;
+    gcd[i++].creator = GListButtonCreate;
+
+    for ( j=0; j<sizeof(stroketypelist)/sizeof(stroketypelist[0]); j++) {
+	stroketypelist[j].selected = (selected_num == 1) && (j == spl->stroketype);
+	stroketypelist[j].disabled = (selected_num != 1);
+    }
+    stroketypelist[num_enum_stroke].selected = (selected_num > 1);
+    stroketypelist[num_enum_stroke].disabled = (selected_num <= 1);
+
+    label[i].text = (unichar_t *) _("Width:");
+    label[i].text_is_1byte = true;
+    gcd[i].gd.label = &label[i];
+    gcd[i].gd.pos.x = 7; gcd[i].gd.pos.y = gcd[i-1].gd.pos.y+32;
+    gcd[i].gd.flags = gg_enabled|gg_visible;
+    gcd[i++].creator = GLabelCreate;
+
+    sprintf( buffer, "%.2f", spl->width );
+    label[i].text = (unichar_t *) buffer;
+    label[i].text_is_1byte = true;
+    gcd[i].gd.label = &label[i];
+    gcd[i].gd.pos.x = 80; gcd[i].gd.pos.y = gcd[i-1].gd.pos.y-5; gcd[i].gd.pos.width = 80;
+    gcd[i].gd.flags = gg_enabled|gg_visible;
+    gcd[i].gd.cid = CID_Width;
+    gcd[i++].creator = GTextFieldCreate;
+
+    gcd[i].gd.pos.x = 30-3; gcd[i].gd.pos.y = gcd[i-1].gd.pos.y+32;
+    gcd[i].gd.pos.width = -1; gcd[i].gd.pos.height = 0;
+    gcd[i].gd.flags = gg_visible | gg_enabled | gg_but_default;
+    label[i].text = (unichar_t *) _("OK");
+    label[i].text_is_1byte = true;
+    gcd[i].gd.label = &label[i];
+    gcd[i].gd.handle_controlevent = SGID_OK;
+    gcd[i++].creator = GButtonCreate;
+
+    gcd[i].gd.pos.x = -30; gcd[i].gd.pos.y = gcd[i-1].gd.pos.y+3;
+    gcd[i].gd.pos.width = -1; gcd[i].gd.pos.height = 0;
+    gcd[i].gd.flags = gg_visible | gg_enabled | gg_but_cancel;
+    label[i].text = (unichar_t *) _("Cancel");
+    label[i].text_is_1byte = true;
+    gcd[i].gd.label = &label[i];
+    gcd[i].gd.handle_controlevent = SGID_Cancel;
+    gcd[i++].creator = GButtonCreate;
+
+    gcd[i].gd.pos.x = 2; gcd[i].gd.pos.y = 2;
+    gcd[i].gd.pos.width = pos.width-4; gcd[i].gd.pos.height = pos.height-4;
+    gcd[i].gd.flags = gg_enabled|gg_visible|gg_pos_in_pixels;
+    gcd[i].creator = GGroupCreate;
+
+    GGadgetsCreate(gw,gcd);
+
+    GWidgetHidePalettes();
+    GDrawSetVisible(gw,true);
+    while ( !sgid.done )
+        GDrawProcessOneEvent(NULL);
+    CVCharChangedUpdate(cv);
+    GDrawSetVisible(gw,false);
+}
+
+static void CVMenuStrokeInfo(GWindow gw,struct gmenuitem *mi,GEvent *e) {
+    CharView *cv = (CharView *) GDrawGetUserData(gw);
+    SplinePointList *spl;
+    int selected_num = 0;
+
+    if (CVPointsSel(cv, &spl, &selected_num))
+	StrokeGetInfo(cv, spl, selected_num);
+}
+#endif
+
 static void _CVMenuPointType(CharView *cv,struct gmenuitem *mi) {
     int pointtype = mi->mid==MID_Corner?pt_corner:mi->mid==MID_Tangent?pt_tangent:pt_curve;
     SplinePointList *spl;
@@ -5602,6 +6022,9 @@
 
 static void cv_ptlistcheck(CharView *cv,struct gmenuitem *mi,GEvent *e) {
     int type = -2, cnt=0, ccp_cnt=0, spline_selected=0;
+#ifdef FONTFORGE_CONFIG_CLWFK
+    int locked = -2, islinkpt = -2;
+#endif
     SplinePointList *spl, *sel=NULL;
     Spline *spline, *first;
     SplinePoint *selpt=NULL;
@@ -5614,6 +6037,12 @@
 	    selpt = spl->first; ++cnt;
 	    if ( type==-2 ) type = spl->first->pointtype;
 	    else if ( type!=spl->first->pointtype ) type = -1;
+#ifdef FONTFORGE_CONFIG_CLWFK
+	    if ( locked==-2 ) locked = spl->first->locked;
+	    else if ( locked!=spl->first->locked ) locked = -1;
+	    if ( islinkpt==-2 ) islinkpt = spl->first->islinkpt;
+	    else if ( locked!=spl->first->islinkpt ) islinkpt = -1;
+#endif
 	    if ( !spl->first->nonextcp && !spl->first->noprevcp && spl->first->prev!=NULL )
 		++ccp_cnt;
 	    if ( notimplicit==-1 ) notimplicit = spl->first->dontinterpolate;
@@ -5623,6 +6052,12 @@
 	    if ( spline->to->selected ) {
 		if ( type==-2 ) type = spline->to->pointtype;
 		else if ( type!=spline->to->pointtype ) type = -1;
+#ifdef FONTFORGE_CONFIG_CLWFK
+		if ( locked==-2 ) locked = spline->to->locked;
+		else if ( locked!=spline->to->locked ) locked = -1;
+		if ( islinkpt==-2 ) islinkpt = spline->to->islinkpt;
+		else if ( locked!=spline->to->islinkpt ) islinkpt = -1;
+#endif
 		selpt = spline->to;
 		sel = spl; ++cnt;
 		if ( !spline->to->nonextcp && !spline->to->noprevcp && spline->to->next!=NULL )
@@ -5675,6 +6110,16 @@
 	    mi->ti.disabled = AnchorClassUnused(cv->sc,&waslig)==NULL;
 	  break;
 #endif
+#ifdef FONTFORGE_CONFIG_CLWFK
+	  case MID_ToggleLocked:
+	    mi->ti.disabled = locked==-2;
+	    mi->ti.checked = locked==1;
+	  break;
+	  case MID_ToggleLinkPoint:
+	    mi->ti.disabled = islinkpt==-2;
+	    mi->ti.checked = islinkpt==1;
+	  break;
+#endif
 	}
     }
 }
@@ -7678,6 +8123,12 @@
     { { (unichar_t *) N_("Make _Line"), NULL, COLOR_DEFAULT, COLOR_DEFAULT, NULL, NULL, 0, 0, 0, 0, 0, 0, 1, 1, 0, 'M' }, '\0', ksm_control, NULL, NULL, CVMenuMakeLine, MID_MakeLine },
     { { (unichar_t *) N_("Insert Point On _Spline At..."), NULL, COLOR_DEFAULT, COLOR_DEFAULT, NULL, NULL, 0, 0, 0, 0, 0, 0, 1, 1, 0, 'M' }, '\0', ksm_control, NULL, NULL, CVMenuInsertPt, MID_InsertPtOnSplineAt },
     { { (unichar_t *) N_("Center _Between Control Points"), NULL, COLOR_DEFAULT, COLOR_DEFAULT, NULL, NULL, 0, 0, 0, 0, 0, 0, 1, 1, 0, 'M' }, '\0', ksm_control, NULL, NULL, CVMenuCenterCP, MID_CenterCP },
+#ifdef FONTFORGE_CONFIG_CLWFK
+    { { (unichar_t *) N_("_Stroke Info"), NULL, COLOR_DEFAULT, COLOR_DEFAULT, NULL, NULL, 0, 0, 0, 0, 0, 0, 1, 1, 0, 'S' }, '\0', ksm_control, NULL, NULL, CVMenuStrokeInfo, MID_StrokeInfo },
+    { { NULL, NULL, COLOR_DEFAULT, COLOR_DEFAULT, NULL, NULL, 0, 0, 0, 0, 1, 1, 0, 0, }},
+    { { (unichar_t *) N_("Lock/Unlock Line _End"), NULL, COLOR_DEFAULT, COLOR_DEFAULT, NULL, NULL, 0, 0, 1, 0, 0, 0, 1, 1, 0, 'E' }, '\0', ksm_control, NULL, NULL, CVMenuToggleLocked, MID_ToggleLocked },
+    { { (unichar_t *) N_("Set/Unset as Link _Point"), NULL, COLOR_DEFAULT, COLOR_DEFAULT, NULL, NULL, 0, 0, 1, 0, 0, 0, 1, 1, 0, 'P' }, '\0', ksm_control, NULL, NULL, CVMenuToggleLinkPoint, MID_ToggleLinkPoint },
+#endif
     { NULL }
 };
 
@@ -7925,6 +8376,11 @@
     { { (unichar_t *) N_("M_ark Points of Inflection"), NULL, COLOR_DEFAULT, COLOR_DEFAULT, NULL, NULL, 0, 0, 1, 0, 0, 0, 1, 1, 0, 'M' }, '\0', ksm_control, NULL, NULL, CVMenuMarkPointsOfInflection, MID_MarkPointsOfInflection },
     { { (unichar_t *) N_("Show _Control Point Info"), NULL, COLOR_DEFAULT, COLOR_DEFAULT, NULL, NULL, 0, 0, 1, 0, 0, 0, 1, 1, 0, 'M' }, '\0', ksm_control, NULL, NULL, CVMenuShowCPInfo, MID_ShowCPInfo },
     { { (unichar_t *) N_("Fi_ll"), NULL, COLOR_DEFAULT, COLOR_DEFAULT, NULL, NULL, 0, 0, 1, 0, 0, 0, 1, 1, 0, 'l' }, '\0', 0, NULL, NULL, CVMenuFill, MID_Fill },
+#ifdef FONTFORGE_CONFIG_CLWFK
+    { { (unichar_t *) N_("Show Mincho Outline"), NULL, COLOR_DEFAULT, COLOR_DEFAULT, NULL, NULL, 0, 0, 1, 0, 0, 0, 1, 1, 0, 'x' }, '$', ksm_control, NULL, NULL, CVMenuShowMinchoOutline, MID_ShowMinchoOutline },
+    { { (unichar_t *) N_("Show Gothic Outline"), NULL, COLOR_DEFAULT, COLOR_DEFAULT, NULL, NULL, 0, 0, 1, 0, 0, 0, 1, 1, 0, 'y' }, '%', ksm_control, NULL, NULL, CVMenuShowGothicOutline, MID_ShowGothicOutline },
+    { { (unichar_t *) N_("Normalize Kanji Size"), NULL, COLOR_DEFAULT, COLOR_DEFAULT, NULL, NULL, 0, 0, 1, 0, 0, 0, 1, 1, 0, 'l' }, '\0', 0, NULL, NULL, CVToggleNormKanji, MID_NormKanji },
+#endif
     { { (unichar_t *) N_("Sho_w Grid Fit..."), NULL, COLOR_DEFAULT, COLOR_DEFAULT, NULL, NULL, 0, 0, 1, 0, 0, 0, 1, 1, 0, 'l' }, '\0', 0, NULL, NULL, CVMenuShowGridFit, MID_ShowGridFit },
     { { NULL, NULL, COLOR_DEFAULT, COLOR_DEFAULT, NULL, NULL, 0, 0, 0, 0, 0, 1, }},
     { { (unichar_t *) N_("Com_binations"), NULL, COLOR_DEFAULT, COLOR_DEFAULT, NULL, NULL, 0, 0, 0, 0, 0, 0, 1, 1, 0, 'b' }, '\0', ksm_shift|ksm_control, cblist, cblistcheck },
@@ -8651,6 +9107,7 @@
     CharView *cv = sv->cv_srch.inactive ? &sv->cv_rpl : &sv->cv_srch;
     _CVMenuDir(cv,mi);
 }
+
 
 static void SVMenuCorrectDir(GWindow gw,struct gmenuitem *mi,GEvent *e) {
     SearchView *sv = (SearchView *) GDrawGetUserData(gw);
--- fontforge/cvaddpoints.c.orig	Fri Jan 13 11:25:42 2006
+++ fontforge/cvaddpoints.c	Mon Mar  6 18:03:41 2006
@@ -153,6 +153,47 @@
 return( false );
 }
 
+#ifdef FONTFORGE_CONFIG_CLWFK
+int CVPointsSel(CharView *cv,
+		   SplinePointList **_spl,
+		   int *selected_num) {
+        /* if there are selected points, return the first one and the number of selected items*/
+
+	SplinePointList *spl, *found=NULL;
+	Spline *spline;
+
+	*selected_num = 0;
+	for (spl = cv->layerheads[cv->drawmode]->splines; spl != NULL; spl = spl->next) {
+		if (spl->first->selected ) {
+			if (found == NULL) {
+				*selected_num = 1;
+				found = spl;
+			}
+			else if (found != spl)
+				(*selected_num)++;
+		}
+		for (spline = spl->first->next; spline != NULL; spline = spline->to->next ) {
+			if (spline->to == spl->first )
+				break;
+			if (spline->to->selected) {
+				if (found == NULL) {
+					*selected_num = 1;
+					found = spl;
+				}
+				else if (found != spl)
+					(*selected_num)++;
+			}
+		}
+	}
+	*_spl = found;
+
+    if (found)
+	    return (true);
+
+    return (false);
+}
+#endif
+
 SplinePointList *CVAnySelPointList(CharView *cv) {
     /* if there is exactly one point selected and it is on an open splineset */
     /*  and it is one of the endpoints of the splineset, then return that */
@@ -207,6 +248,20 @@
 return( found );
 }
 
+#ifdef FONTFORGE_CONFIG_CLWFK
+static int NumberOfPointsAre(SplinePoint *sp, int num) {
+    while (sp != NULL) {
+	if (num-- < 0)
+return false;
+	sp = (sp->prev == NULL) ? NULL : sp->prev->from;
+    }
+    if (num != 0)
+return false;
+    else
+return true;
+}
+#endif
+
 /* When the user tries to add a point (by doing a mouse down with a point tool
   selected) there are several cases to be looked at:
 	If there is a single point selected and it is at the begining/end of an open spline set
@@ -370,10 +425,21 @@
 	sp->nextcpdef = sp->prevcpdef = 1;
 	sp->pointtype = ptype;
 	sp->selected = true;
+#ifdef FONTFORGE_CONFIG_CLWFK
+	ss->width = sc->parent->strokewidth;
+	ss->stroketype = sc->parent->last_stroketype;
+#endif
     }
 
     cv->active_spl = ss;
     cv->active_sp = sp;
+#ifdef FONTFORGE_CONFIG_CLWFK
+    if (sc->parent->strokedfont) {
+	sp->locked = true;
+	if (NumberOfPointsAre(sp, num_edges_in_strokes[ss->stroketype]))
+	    sp->selected = false;
+    }
+#endif
     CVSetCharChanged(cv,true);
     CVInfoDraw(cv,cv->gw);
     SCUpdateAll(sc);
--- fontforge/cvexport.c.orig	Thu Mar 16 09:32:16 2006
+++ fontforge/cvexport.c	Fri Mar 17 14:38:57 2006
@@ -38,6 +38,245 @@
 #include <utype.h>
 #endif
 
+#ifdef FONTFORGE_CONFIG_CLWFK
+static int BPIndex(BasePoint bp, BasePoint *array, int arraysize) {
+    int i;
+    for ( i = 0; i < arraysize; i++ ) {
+        if ( array[i].x == bp.x && array[i].y == bp.y )
+return( i );
+    }
+return( -1 );
+}
+
+typedef struct splinepointiterator {
+    SplinePointList *spl;
+    SplinePoint *cur;
+} SPIterator;
+
+static SplinePoint *nextSP(SPIterator *iter) {
+    if (iter->cur == NULL) {
+        iter->cur = iter->spl->first;
+    } else if (iter->cur->next==NULL) {
+        iter->cur = NULL;
+    } else if (iter->cur->next->to==iter->spl->first) {
+        iter->cur = NULL;
+    } else {
+        iter->cur = iter->cur->next->to;
+    }
+return iter->cur;
+}
+
+static void initSPIterator(SPIterator *iter, SplinePointList *spl) {
+    iter->spl = spl;
+    iter->cur = NULL;
+}
+
+int ExportNamedPrimitive(FILE *skel, SplineChar *sc, char *glyphname) {
+    int i, good, numPoints = 0;
+    SplinePointList *spl;
+    SplinePoint *sp;
+    SPIterator iter;
+    BasePoint points[256];
+    int linkok[256], joints[128];
+    SkelParams *fk = &sc->clwfk;
+
+    for (i = 0; i < 256; i++)
+	linkok[i] = false;
+    SCRound2Int(sc,1.0);
+
+    if (sc->name==NULL || strcmp(sc->name,".notdef")==0)
+	fprintf(skel, "(setq UNKNOWN\n      '((");
+    else
+	fprintf(skel, "(setq %s\n      '((", sc->name);
+
+
+    for ( spl=sc->layers[1].splines; spl!=NULL; spl=spl->next )
+        if ( spl->stroketype < sk_kamae )
+	    for ( initSPIterator(&iter, spl); (sp=nextSP(&iter)) != NULL; ) {
+		i = BPIndex(sp->me, points, numPoints);
+		if ( i < 0 )
+		    points[i = numPoints++] = sp->me;
+		if ( sp->islinkpt )
+		  linkok[i] = true;
+	    }
+
+    for ( i=0; i<numPoints; i++ ) {
+        fprintf(skel, "%s(%d %d", i==0?"":"        ", 
+		(int)(points[i].x*0.4), (int)((points[i].y-800)*-0.4));
+        if ( linkok[i] ) 
+	    fprintf(skel, " (link-ok t)");
+        fprintf(skel, "%s", i==numPoints-1?"))\n":")\n");
+    }
+
+    fprintf(skel, "%s", "       (");
+    for ( spl=sc->layers[ly_fore].splines; spl!=NULL; spl=spl->next ) {
+        int nJoints=0;
+	if ( spl->stroketype >= sk_kamae )
+    continue;
+        fprintf(skel, "%s(%s (", spl==sc->layers[ly_fore].splines?"":"        ",
+		                stroketypes[spl->stroketype]);
+	for ( initSPIterator(&iter, spl); (sp=nextSP(&iter)) != NULL; ) {
+            BasePoint me = sp->me;
+	    if ( sp->islinkpt && sp->prev!=NULL && sp->next!=NULL && sp->next->to!=spl->first ) {
+	        joints[nJoints++] = BPIndex(me,points,numPoints);
+	    } else {
+	        fprintf(skel, "%d", BPIndex(me,points,numPoints));
+		if ( sp->next!=NULL && sp->next->to!=spl->first )
+		    fputc(' ', skel);
+	    }
+	}
+	fprintf(skel, ")");
+
+	if (nJoints > 0) {
+	    fprintf(skel, " (link ");
+	    for ( i=0; i<nJoints; i++ ) {
+		fprintf(skel, "%d", joints[i]);
+		if (i < nJoints-1) fprintf(skel, " ");
+	    }
+	    fprintf(skel, ")");
+	}
+	if ( spl->width != 0 && sc->parent->strokewidth != 0 &&
+	     spl->width != sc->parent->strokewidth )
+	    fprintf(skel, " (widthratio . %.3f)", spl->width / sc->parent->strokewidth);
+	fprintf(skel, spl->next==NULL?")":")\n");
+    }
+    fprintf(skel, ")\n");
+
+    if ( fk->xlimit_min!=0 || (fk->xlimit_max!=0 && fk->xlimit_max!=1000 ))
+        fprintf(skel, "\n       (xlimit %g %g)", fk->xlimit_min, fk->xlimit_max);
+    if ( fk->ylimit_min!=0 || (fk->ylimit_max!=0 && fk->ylimit_max!=1000 ))
+        fprintf(skel, "\n       (ylimit %g %g)", fk->ylimit_min, fk->ylimit_max);
+
+    for ( spl=sc->layers[ly_fore].splines; spl!=NULL; spl=spl->next ) {
+        if ( spl->stroketype >= sk_kamae )
+	    fprintf(skel, "      (%s %.1f %.1f %.1f %.1f)\n", stroketypes[spl->stroketype],
+		    spl->first->me.x*0.4, (spl->first->me.y-800)*(-0.4),
+		    spl->first->next->to->next->to->me.x*0.4,
+		    (spl->first->next->to->next->to->me.y-800)*(-0.4));
+    }
+    if ( fk->tateheight != 0 ) fprintf(skel, "       (tateheight . %f)\n", fk->tateheight);
+    if ( fk->yokowidth != 0 ) fprintf(skel, "       (yokowidth . %f)\n", fk->yokowidth);
+    if ( fk->xunit != 0 ) fprintf(skel, "       (xunit . %f)\n", fk->xunit);
+    if ( fk->yunit != 0 ) fprintf(skel, "       (yunit . %f)\n", fk->yunit);
+    if ( fk->xlimit_min != 0 || (fk->xlimit_max != 0 && fk->xlimit_max != 400 ))
+	fprintf(skel, "       (xlimit . %f %f)\n", fk->xlimit_min, fk->xlimit_max);
+    if ( fk->ylimit_min != 0 || (fk->ylimit_max != 0 && fk->ylimit_max != 400 ))
+	fprintf(skel, "       (ylimit . %f %f)\n", fk->ylimit_min, fk->ylimit_max);
+    if ( fk->center == 200 ) fprintf(skel, "       (center)\n");
+    else if ( fk->center != 0 ) fprintf(skel, " (center . %f)\n",fk->center);
+    if ( fk->up!=0 || fk->down!=0 ) 
+        fprintf(skel, "       (updown %f . %f)\n", fk->up, fk->down);
+    if ( fk->hook!=NULL)
+        fprintf(skel, "       (hook  %s)\n", fk->hook);
+    fprintf(skel, "))\n");
+    
+    good = !ferror(skel);
+return( good );
+}
+
+int ExportPrimitive(FILE *skel, SplineChar *sc) {
+return( ExportNamedPrimitive(skel,sc,sc->name) );
+}
+
+static void ExportJointSkel(FILE *skel, SplineChar *sc, int use_jointdef) {
+    RefChar *ref;
+    int cnt;
+
+    if ( use_jointdef ) {
+	if ( sc->clwfk.jointdef!=NULL ) {
+	    char *def = u2utf8_copy(sc->clwfk.jointdef);
+	    fprintf(skel, ";(setq %s '%s)\n", sc->name, def);
+	    free(def);
+	}
+	fprintf(skel, "(defjoint gothic %s\n", sc->name);
+    } else {
+	fprintf(skel, "(setq %s\n", sc->name);
+    }
+
+    fprintf(skel, "      '(joint '(");
+    cnt = 0;
+    for ( ref = sc->layers[ly_fore].refs; ref!=NULL; ref=ref->next ) {
+	fprintf(skel, "%s#(%f %f %f %f %f %f)%s", 
+		(cnt++ == 0) ? "" : "                ",
+		ref->transform[0], ref->transform[1], ref->transform[2],
+		ref->transform[3], ref->transform[4]*0.4, 
+		ref->transform[5]*(-0.4)+(1-ref->transform[3])*320,
+		(ref->next==NULL) ? "" : "\n");
+    }
+    fprintf(skel, ")\n      '(");
+    for ( ref = sc->layers[ly_fore].refs; ref!=NULL; ref=ref->next ) {
+	fprintf(skel, "%s", ref->sc->name );
+	if ( ref->next!=NULL )
+	    fputc(' ', skel);
+    }
+    fprintf(skel, ")\n      nil))\n\n");
+}
+
+static int isJointSkel(SplineChar *sc) {
+    if ( sc->layers[ly_fore].refs != NULL )
+return( true );
+    else
+return( false );
+}
+
+static int ExportJointSkelAndDeps(FILE *skel, SplineChar *sc) {
+    int enc, good=true;
+    RefChar *ref;
+    SplineChar *dep;
+
+    for ( ref = sc->layers[ly_fore].refs; ref!=NULL; ref=ref->next ) {
+	enc = SFFindGID(sc->parent, -1, ref->sc->name);
+	if (enc < 0 || enc > sc->parent->glyphcnt)
+return( good = false );
+	dep = sc->parent->glyphs[enc];
+	if ( dep==NULL )
+return( good = false );
+	if ( isJointSkel(dep) ) {
+	    if (ExportJointSkelAndDeps(skel, dep) != 0 )
+return( good = false );
+	} else
+	    if ( ExportPrimitive(skel, dep)==0 )
+return( good );
+    }
+
+    ExportJointSkel(skel, sc, false);
+return( good );
+}
+
+static int _ExportSkeletonAndDepends(FILE *skel, SplineChar *sc, int export_deps, int use_jointdef) {
+    int good = true;
+
+    if ( !isJointSkel(sc) )
+	good = ExportPrimitive(skel,sc);
+    else if ( export_deps )
+	good = ExportJointSkelAndDeps(skel,sc);
+    else
+	ExportJointSkel(skel,sc,use_jointdef);
+
+return ( good );
+}
+
+int ExportSkeletonAndDepends(FILE *skel, SplineChar *sc) {
+    return _ExportSkeletonAndDepends(skel,sc,true,false);
+}
+
+int ExportSkeleton(FILE *skel, SplineChar *sc, int use_jointdef) {
+    return _ExportSkeletonAndDepends(skel,sc, false,use_jointdef);
+}
+
+static int ExportSkeletonFile(char *filename, SplineChar *sc) {
+    FILE *skel;
+    int good;
+
+    skel = fopen(filename,"w");
+    if ( skel==NULL )
+return( false );
+    good = ExportSkeleton(skel,sc,true);
+    fclose(skel);
+return ( good );
+}
+#endif
+
 static void EpsGeneratePreview(FILE *eps,SplineChar *sc,DBounds *b) {
     double scale, temp;
     int pixelsize, depth;
@@ -743,6 +982,10 @@
 	good = ExportSVG(buffer,sc);
     else if ( format==3 )
 	good = ExportPDF(buffer,sc);
+#ifdef FONTFORGE_CONFIG_CLWFK
+    else if ( format==4 )
+	good = ExportSkeletonFile(buffer,sc);
+#endif
     else if ( bc!=NULL )
 	good = BCExportXBM(buffer,bc,format-4);
     if ( !good )
@@ -773,6 +1016,9 @@
     { (unichar_t *) N_("XFig"), NULL, 0, 0, NULL, 0, 0, 0, 0, 0, 0, 0, 1 },
     { (unichar_t *) N_("SVG"), NULL, 0, 0, NULL, 0, 0, 0, 0, 0, 0, 0, 1 },
     { (unichar_t *) N_("PDF"), NULL, 0, 0, NULL, 0, 0, 0, 0, 0, 0, 0, 1 },
+#ifdef FONTFORGE_CONFIG_CLWFK
+    { (unichar_t *) N_("Skeleton"), NULL, 0, 0, NULL, 0, 0, 0, 0, 0, 0, 0, 1 },
+#endif
     { (unichar_t *) N_("X Bitmap"), NULL, 0, 0, NULL, 0, 0, 0, 0, 0, 0, 0, 1 },
     { (unichar_t *) N_("BMP"), NULL, 0, 0, NULL, 0, 0, 0, 0, 0, 0, 0, 1 },
 #ifndef _NO_LIBPNG
@@ -799,8 +1045,15 @@
 	good = ExportSVG(temp,d->sc);
     else if ( format==3 )
 	good = ExportPDF(temp,d->sc);
+#ifdef FONTFORGE_CONFIG_CLWFK
+    else if ( format==4 )
+	good = ExportSkeletonFile(temp,d->sc);
+    else
+	good = ExportXBM(temp,d->sc,format-5);
+#else
     else
 	good = ExportXBM(temp,d->sc,format-4);
+#endif
     if ( !good )
 	gwwv_post_error(_("Save Failed"),_("Save Failed"));
     free(temp);
@@ -876,8 +1129,14 @@
 			 format==1?".fig":
 			 format==2?".svg":
 			 format==3?".pdf":
+#ifdef FONTFORGE_CONFIG_CLWFK
+			 format==4?".l":
+			 format==5?".xbm":
+			 format==6?".bmp":
+#else
 			 format==4?".xbm":
 			 format==5?".bmp":
+#endif
 				   ".png");
 	GGadgetSetTitle(d->gfc,f2);
 	free(f2);
@@ -1065,7 +1324,11 @@
 	ext = _format==0 ? "xbm" : _format==1 ? "bmp" : "png";
     else
 	ext = _format==0?"eps":_format==1?"fig":_format==2?"svg":
+#ifdef FONTFORGE_CONFIG_CLWFK
+		_format==3?"pdf":_format==4?"l":_format==5?"xbm":_format==6?"bmp":"png";
+#else
 		_format==3?"pdf":_format==4?"xbm":_format==5?"bmp":"png";
+#endif
 #if defined( __CygWin ) || defined(__Mac)
     /* Windows file systems are not case conscious */
     { char *pt, *bpt, *end;
--- fontforge/cvfreehand.c.orig	Mon Jan 31 11:11:19 2005
+++ fontforge/cvfreehand.c	Sun May  1 00:57:59 2005
@@ -559,6 +559,10 @@
     /* Splice things together */
     spl = chunkalloc(sizeof(SplineSet));
     spl->first = last = SplinePointCreate(head->here.x,head->here.y);
+#ifdef FONTFORGE_CONFIG_CLWFK
+    spl->width = cv->sc->parent->strokewidth;
+    spl->stroketype = sk_hira_long;
+#endif
     last->ptindex = 0;
 
     for ( base=head; base!=NULL && base->next!=NULL; base = pt ) {
--- fontforge/cvgetinfo.c.orig	Thu Sep 28 05:50:35 2006
+++ fontforge/cvgetinfo.c	Sun Nov 12 11:51:32 2006
@@ -88,6 +88,11 @@
 #define CID_DeltaCurvature	2045
 #define CID_TabSet	2100
 
+#ifdef FONTFORGE_CONFIG_CLWFK
+#define CID_StrokeType  1001
+#define CID_Width	1002
+#endif
+
 #define CID_X		3001
 #define CID_Y		3002
 #define CID_NameList	3003
@@ -1767,7 +1772,15 @@
 return( true );
 }
 
+#ifdef FONTFORGE_CONFIG_CLWFK
+extern GTextInfo stroketypelist[30];
+#endif
+
 static int PI_Ok(GGadget *g, GEvent *e) {
+#ifdef FONTFORGE_CONFIG_CLWFK
+    int err=false;
+#endif
+
     if ( e->type==et_controlevent && e->u.control.subtype == et_buttonactivate ) {
 	GIData *ci = GDrawGetUserData(GGadgetGetWindow(g));
 
@@ -1777,6 +1790,12 @@
 	PI_FigureNext(ci);
 	PI_FigurePrev(ci);
 
+#ifdef FONTFORGE_CONFIG_CLWFK
+	ci->curspl->width = GetReal8(ci->gw,CID_Width,_("Width"), &err);
+	ci->curspl->stroketype = (int) (GGadgetGetListItemSelected(GWidgetGetControl(ci->gw,CID_StrokeType))->userdata);
+	ci->cv->sc->parent->last_stroketype = ci->curspl->stroketype;
+#endif
+
 	ci->done = true;
 	/* All the work has been done as we've gone along */
     }
@@ -1930,9 +1949,9 @@
 	strcpy( buffer, _("Curvature: ?"));
     GGadgetSetTitle8(GWidgetGetControl(ci->gw,CID_PrevCurvature),buffer);
     if ( kappa!=CURVATURE_ERROR && kappa2!=CURVATURE_ERROR )
-	sprintf( buffer, "∆: %g", (kappa-kappa2)*emsize );
+	sprintf( buffer, "[2],H[0],F(B: %g", (kappa-kappa2)*emsize );
     else
-	strcpy( buffer, "∆: ?");
+	strcpy( buffer, "[2],H[0],F(B: ?");
     GGadgetSetTitle8(GWidgetGetControl(ci->gw,CID_DeltaCurvature),buffer);
 }
 
@@ -2510,7 +2529,14 @@
 	*varray[11], *harray1[4], *harray2[6], *hvarray1[25], *hvarray2[25],
 	*hvarray3[16], *harray3[11];
     GTextInfo label[54], mlabel[11];
+#ifdef FONTFORGE_CONFIG_CLWFK
+    GGadgetCreateData sgcd[6];
+    GTextInfo slabel[6];
+    GTabInfo aspects[6];
+    char buffer[30];
+#else
     GTabInfo aspects[4];
+#endif
     static GBox cur, nextcp, prevcp;
     extern Color nextcpcol, prevcpcol;
     GWindow root;
@@ -2561,6 +2587,10 @@
 	memset(&hgcd,0,sizeof(hgcd));
 	memset(&h2gcd,0,sizeof(h2gcd));
 	memset(&mgcd,0,sizeof(mgcd));
+#ifdef FONTFORGE_CONFIG_CLWFK
+	memset(&sgcd,0,sizeof(sgcd));
+	memset(&slabel,0,sizeof(slabel));
+#endif
 	memset(&mlabel,0,sizeof(mlabel));
 	memset(&aspects,0,sizeof(aspects));
 	memset(&pb,0,sizeof(pb));
@@ -2723,7 +2753,7 @@
 	hvarray1[l++] = &gcd[j];
 	++j;
 
-	label[j].text = (unichar_t *) U_("°");
+	label[j].text = (unichar_t *) U_("");
 	label[j].text_is_1byte = true;
 	gcd[j].gd.label = &label[j];
 	gcd[j].gd.pos.x = gcd[j-1].gd.pos.x+gcd[j-1].gd.pos.width+2; gcd[j].gd.pos.y = gcd[j-3].gd.pos.y; 
@@ -2836,7 +2866,7 @@
 	hvarray2[l++] = &gcd[j];
 	++j;
 
-	label[j].text = (unichar_t *) U_("°");
+	label[j].text = (unichar_t *) U_("");
 	label[j].text_is_1byte = true;
 	gcd[j].gd.label = &label[j];
 	gcd[j].gd.pos.x = gcd[j-1].gd.pos.x+gcd[j-1].gd.pos.width+2; gcd[j].gd.pos.y = gcd[j-3].gd.pos.y; 
@@ -2855,7 +2885,7 @@
 	hvarray2[l++] = &gcd[j]; hvarray2[l++] = GCD_ColSpan; hvarray2[l++] = GCD_ColSpan;
 	++j;
 
-	label[j].text = (unichar_t *) "∆: -0.00000000";
+	label[j].text = (unichar_t *) "[2],H[0],F(B: -0.00000000";
 	label[j].text_is_1byte = true;
 	gcd[j].gd.label = &label[j];
 	gcd[j].gd.pos.x = 130; gcd[j].gd.pos.y = gcd[j-1].gd.pos.y;
@@ -3131,6 +3161,52 @@
 	mgcd[j].creator = GGroupCreate;
 	++j;
 
+#ifdef FONTFORGE_CONFIG_CLWFK
+	j = 0;
+
+	slabel[j].text = (unichar_t *) _("Stroke Type:");
+	slabel[j].text_is_1byte = true;
+	sgcd[j].gd.label = &slabel[j];
+	sgcd[j].gd.pos.x = 7; sgcd[j].gd.pos.y = 7+3+5; 
+	sgcd[j].gd.flags = gg_enabled|gg_visible;
+	sgcd[j++].creator = GLabelCreate;
+
+	sgcd[j].gd.pos.x = 80; sgcd[j].gd.pos.y = gcd[j-1].gd.pos.y-5;
+	sgcd[j].gd.pos.width = 100;
+	sgcd[j].gd.flags = gg_enabled|gg_visible;
+	sgcd[j].gd.cid = CID_StrokeType;
+	sgcd[j].gd.u.list = stroketypelist;
+	for ( k=0; ; k++) {
+	    if (stroketypelist[k].text == NULL)
+	break;
+	    stroketypelist[k].selected = (k == spl->stroketype);
+	    stroketypelist[k].disabled = false;
+	}
+	sgcd[j++].creator = GListButtonCreate;
+
+	slabel[j].text = (unichar_t *) _("Width:");
+	slabel[j].text_is_1byte = true;
+	sgcd[j].gd.label = &slabel[j];
+	sgcd[j].gd.pos.x = 7; sgcd[j].gd.pos.y = sgcd[j-1].gd.pos.y+32;
+	sgcd[j].gd.flags = gg_enabled|gg_visible;
+	sgcd[j++].creator = GLabelCreate;
+
+	sprintf( buffer, "%.3f", spl->width );
+	slabel[j].text = (unichar_t *) buffer;
+	slabel[j].text_is_1byte = true;
+	sgcd[j].gd.label = &slabel[j];
+	sgcd[j].gd.pos.x = 80; sgcd[j].gd.pos.y = sgcd[j-1].gd.pos.y-5;
+	sgcd[j].gd.pos.width = 80;
+	sgcd[j].gd.flags = gg_enabled|gg_visible;
+	sgcd[j].gd.cid = CID_Width;
+	sgcd[j++].creator = GTextFieldCreate;
+#if 0
+#endif
+	sgcd[j].gd.pos.x = 2; sgcd[j].gd.pos.y = 2;
+	sgcd[j].gd.pos.width = pos.width-4; sgcd[j].gd.pos.height = pos.height-4;
+	sgcd[j].gd.flags = gg_enabled|gg_visible|gg_pos_in_pixels;
+	sgcd[j].creator = GGroupCreate;
+#endif
 	marray[0] = &mgcd[0]; marray[1] = NULL;
 	marray[2] = &mb[2]; marray[3] = NULL;
 	marray[4] = &mb[3]; marray[5] = NULL;
--- fontforge/cvimages.c.orig	Fri Jan 13 11:25:42 2006
+++ fontforge/cvimages.c	Sun Mar 12 11:41:24 2006
@@ -72,6 +72,9 @@
 static unichar_t wildmac[] = { '*', '{', 'b', 'i', 'n', ',', 'h', 'q', 'x', ',', 'd','f','o','n','t', '}',  '\0' };
 static unichar_t wildwin[] = { '*', '{', 'f', 'o', 'n', ',', 'f', 'n', 't', '}',  '\0' };
 static unichar_t wildpalm[] = { '*', 'p', 'd', 'b',  '\0' };
+#ifdef FONTFORGE_CONFIG_CLWFK
+static unichar_t wildskel[] = { '*', '.', 'l', '\0' };
+#endif
 static unichar_t *wildchr[] = { wildimg, wildps,
 #ifndef _NO_LIBXML
 wildsvg,
@@ -83,6 +86,9 @@
 #ifndef _NO_LIBXML
 , wildsvg, wildsvgtemplate
 #endif
+#ifdef FONTFORGE_CONFIG_CLWFK
+, wildskel
+#endif
 };
 
 #define PSSF_Width 220
@@ -1229,6 +1235,13 @@
 return( true );
 }
 
+#ifdef FONTFORGE_CONFIG_CLWFK
+int FVImportSkeleton(FontView *fv,char *path,int toback, int flags) {
+    fprintf(stderr, "Importing Skeleton is not supported yet.\n");
+return( false );
+}
+#endif
+
 /****************************** Import picker *********************************/
 #ifndef FONTFORGE_CONFIG_NO_WINDOWING_UI
 
@@ -1269,6 +1282,9 @@
     { (unichar_t *) N_("SVG"), NULL, 0, 0, (void *) fv_svg, 0, 0, 0, 0, 0, 0, 0, 1 },
     { (unichar_t *) N_("SVG Template"), NULL, 0, 0, (void *) fv_svgtemplate, 0, 0, 0, 0, 0, 0, 0, 1 },
 #endif
+#ifdef FONTFORGE_CONFIG_CLWFK
+    { (unichar_t *) N_("CLWFK Skeleton"), NULL, 0, 0, (void *) fv_skel, 0, 0, 0, 0, 0, 0, 0, 1 },
+#endif
     { NULL }};
 
 static int GFD_ImportOk(GGadget *g, GEvent *e) {
@@ -1319,6 +1335,10 @@
 		d->done = FVImportImages(d->fv,temp,format,toback,-1);
 	    else if ( format==fv_svgtemplate )
 		d->done = FVImportImageTemplate(d->fv,temp,format,toback,-1);
+#ifdef FONTFORGE_CONFIG_CLWFK
+	    else if ( format==fv_skel )
+		d->done = FVImportSkeleton(d->fv,temp,toback,-1);
+#endif
 	} else if ( d->bv!=NULL )
 	    d->done = BVImportImage(d->bv,temp);
 	else {
--- fontforge/cvknife.c.orig	Sun Jan  2 00:05:56 2005
+++ fontforge/cvknife.c	Sun May  1 00:57:59 2005
@@ -67,6 +67,10 @@
 	nspl->first = n;
 	nspl->last = p->spl->last;
 	p->spl->last = p->sp;
+#ifdef FONTFORGE_CONFIG_CLWFK
+	nspl->width = p->spl->width;
+	nspl->stroketype = p->spl->stroketype;
+#endif
     }
     
     cv->lastknife.x = cv->info.x;
@@ -159,6 +163,10 @@
 			    spl2->first = mid2;
 			    spl2->last = spl->last;
 			    spl->last = mid;
+#ifdef FONTFORGE_CONFIG_CLWFK
+			    spl2->width = spl->width;
+			    spl2->stroketype = spl->stroketype;
+#endif
 			}
 		    }
 		}
--- fontforge/cvpalettes.c.orig	Fri Jan 13 11:25:42 2006
+++ fontforge/cvpalettes.c	Mon Mar  6 19:13:08 2006
@@ -872,6 +872,15 @@
 	if ( event->u.mouse.clicks>=2 &&
 		(pos/2 == cvt_scale/2 || pos/2 == cvt_rotate/2 || pos == cvt_3d_rotate ))
 	    CVDoTransform(cv,pos);
+#ifdef FONTFORGE_CONFIG_CLWFK
+{
+        SplinePointList *spl;
+        int selected_num;
+	if ( event->u.mouse.clicks>=2 && CVPointsSel(cv,&spl,&selected_num) &&
+		(pos == cvt_curve || pos == cvt_corner || pos == cvt_tangent ))
+	    StrokeGetInfo(cv, spl, selected_num);
+}
+#endif
     } else if ( event->type == et_mousemove ) {
 	if ( cv->pressed_tool==cvt_none && pos!=cvt_none )
 	    /* Not pressed */
@@ -1319,7 +1328,11 @@
       break;
       case et_mousedown: {
 	int layer = (event->u.mouse.y-CV_LAYERS2_HEADER_HEIGHT)/CV_LAYERS2_LINE_HEIGHT;
+#ifdef FONTFORGE_CONFIG_CLWFK /* really? */
+	if ( event->u.mouse.y>CV_LAYERS2_HEADER_HEIGHT && layer<=cv->sc->layer_cnt ) {
+#else
 	if ( event->u.mouse.y>CV_LAYERS2_HEADER_HEIGHT ) {
+#endif
 	    if ( layer<2 ) {
 		cv->drawmode = layer==0 ? dm_grid : dm_back;
 		layer2.active = layer;
--- fontforge/cvpointer.c.orig	Mon Jul 24 11:54:21 2006
+++ fontforge/cvpointer.c	Sun Nov 12 11:58:04 2006
@@ -504,6 +504,34 @@
 return( false );
 }
 
+#ifdef FONTFORGE_CONFIG_CLWFK
+static void SetSelectedAt(CharView *cv, BasePoint bp, int selected) {
+    SplinePointList *spl;
+    SplinePoint *sp;
+
+    for ( spl=cv->sc->layers[CVLayer(cv)].splines; spl!=NULL; spl=spl->next ) {
+	    sp = spl->first;
+	    if ( sp->me.x==bp.x && sp->me.y==bp.y )
+		sp->selected = selected;
+	    sp = ( sp->next==NULL ) ? NULL : sp->next->to;
+	    while ( sp!=NULL && sp!= spl->first ) {
+		if ( sp->me.x==bp.x && sp->me.y==bp.y )
+		    sp->selected = selected;
+		sp = ( sp->next==NULL ) ? NULL : sp->next->to;
+	    }
+    }
+}
+
+static void SelectOtherPointsOnLinkPoint(CharView *cv, FindSel *fs) {
+    if ( fs->p->sp!=NULL && fs->p->sp->islinkpt )
+	SetSelectedAt(cv, fs->p->sp->me, fs->p->sp->selected);
+    else if (fs->p->spline != NULL) {
+	SetSelectedAt(cv, fs->p->spline->to->me, fs->p->spline->to->selected);
+	SetSelectedAt(cv, fs->p->spline->from->me, fs->p->spline->from->selected);
+    }
+}
+#endif
+
 void CVMouseDownPointer(CharView *cv, FindSel *fs, GEvent *event) {
     int needsupdate = false;
     int dowidth, dovwidth, nearcaret;
@@ -591,6 +619,10 @@
 	    if ( !fs->p->ap->selected ) needsupdate = true;
 	    fs->p->ap->selected = true;
 	}
+#ifdef FONTFORGE_CONFIG_CLWFK
+	if ( needsupdate && !(event->u.mouse.state&ksm_control))
+	    SelectOtherPointsOnLinkPoint(cv, fs);
+#endif
     } else if ( event->u.mouse.clicks<=1 ) {
 	if ( fs->p->nextcp || fs->p->prevcp )
 	    /* Nothing to do */;
@@ -611,16 +643,28 @@
 	    needsupdate = true;
 	    fs->p->ap->selected = !fs->p->ap->selected;
 	}
+#ifdef FONTFORGE_CONFIG_CLWFK
+	if ( needsupdate && !(event->u.mouse.state&ksm_control))
+	    SelectOtherPointsOnLinkPoint(cv, fs);
+#endif
     } else if ( event->u.mouse.clicks==2 ) {
 	CPEndInfo(cv);
 	if ( fs->p->spl!=NULL ) {
 	    Spline *spline, *first;
 	    if ( !fs->p->spl->first->selected ) { needsupdate = true; fs->p->spl->first->selected = true; }
+#ifdef FONTFORGE_CONFIG_CLWFK
+	    if ( needsupdate && !(event->u.mouse.state&ksm_control))
+		SetSelectedAt(cv, fs->p->spl->first->me, fs->p->spl->first->selected);
+#endif
 	    first = NULL;
 	    for ( spline = fs->p->spl->first->next; spline!=NULL && spline!=first; spline=spline->to->next ) {
 		if ( !spline->to->selected )
 		    { needsupdate = true; spline->to->selected = true; }
 		if ( first==NULL ) first = spline;
+#ifdef FONTFORGE_CONFIG_CLWFK
+		if ( needsupdate && !(event->u.mouse.state&ksm_control))
+		    SetSelectedAt(cv, spline->to->me, spline->to->selected);
+#endif
 	    }
 	} else if ( fs->p->ref!=NULL || fs->p->img!=NULL ) {
 	    /* Double clicking on a referenced character doesn't do much */
@@ -920,6 +964,9 @@
 		if ( mergess->first->prev==NULL && (!mergess->first->selected ||
 			!mergess->last->selected)) {
 		    if ( !mergess->first->selected && activess->first->selected &&
+#ifdef FONTFORGE_CONFIG_CLWFK
+			    !mergess->first->locked && !activess->first->locked &&
+#endif
 			    Nearish(mergess->first->me.x-activess->first->me.x,fudge) &&
 			    Nearish(mergess->first->me.y-activess->first->me.y,fudge)) {
 			CVMergeSplineSets(cv,activess->first,activess,
@@ -927,6 +974,9 @@
   goto restart;
 		    }
 		    if ( !mergess->last->selected && activess->first->selected &&
+#ifdef FONTFORGE_CONFIG_CLWFK
+			    !mergess->last->locked && !activess->first->locked &&
+#endif
 			    Nearish(mergess->last->me.x-activess->first->me.x,fudge) &&
 			    Nearish(mergess->last->me.y-activess->first->me.y,fudge)) {
 			CVMergeSplineSets(cv,activess->first,activess,
@@ -934,6 +984,9 @@
   goto restart;
 		    }
 		    if ( !mergess->first->selected && activess->last->selected &&
+#ifdef FONTFORGE_CONFIG_CLWFK
+			    !mergess->first->locked && !activess->last->locked &&
+#endif
 			    Nearish(mergess->first->me.x-activess->last->me.x,fudge) &&
 			    Nearish(mergess->first->me.y-activess->last->me.y,fudge)) {
 			CVMergeSplineSets(cv,activess->last,activess,
@@ -941,6 +994,9 @@
   goto restart;
 		    }
 		    if ( !mergess->last->selected && activess->last->selected &&
+#ifdef FONTFORGE_CONFIG_CLWFK
+			    !mergess->last->locked && !activess->last->locked &&
+#endif
 			    Nearish(mergess->last->me.x-activess->last->me.x,fudge) &&
 			    Nearish(mergess->last->me.y-activess->last->me.y,fudge)) {
 			CVMergeSplineSets(cv,activess->last,activess,
--- fontforge/cvshapes.c.orig	Mon Jul 24 11:54:21 2006
+++ fontforge/cvshapes.c	Sun Nov 12 11:58:53 2006
@@ -86,6 +86,10 @@
     cv->active_shape->next = cv->layerheads[cv->drawmode]->splines;
     cv->layerheads[cv->drawmode]->splines = cv->active_shape;
     cv->active_shape->first = last = SPMake(&cv->info,pt_corner);
+#ifdef FONTFORGE_CONFIG_CLWFK
+    cv->active_shape->width = 0;
+    cv->active_shape->stroketype = sk_tare;
+#endif
 
     /* always make a cubic shape. Then convert to order2 when done */
     /*  the conversion routine already knows about rounding to int */
--- fontforge/diffstubs.c.orig	Sun Mar 12 10:42:53 2006
+++ fontforge/diffstubs.c	Tue Mar 14 15:43:34 2006
@@ -1029,6 +1029,17 @@
 }
 #endif
 
+#ifdef FONTFORGE_CONFIG_CLWFK
+SplineFont *SplineFontBlank(int charcnt) {
+return NULL;
+}
+int SFFindGID(SplineFont *sf, int unienc, const char *name) {
+return unienc;
+}
+void SFAddGlyphAndEncode(SplineFont *sf,SplineChar *sc,EncMap *basemap, int baseenc) {
+}
+#endif
+
 void AltUniFigure(SplineFont *sf,EncMap *map) {
 }
 
--- fontforge/fontview.c.orig	Thu Oct 26 22:52:24 2006
+++ fontforge/fontview.c	Sun Nov 12 12:00:34 2006
@@ -1253,6 +1253,9 @@
 	   "dfont,"
 	   "mf,"
 	   "ik,"
+#ifdef FONTFORGE_CONFIG_CLWFK
+           "l,"
+#endif
 	   "fon,"
 	   "fnt,"
 	   "pdb"
@@ -1597,6 +1600,10 @@
 #define MID_48	2004
 #define MID_72	2014
 #define MID_96	2015
+#ifdef FONTFORGE_CONFIG_HUGE_FONTVIEW
+#define MID_120	2035
+#define MID_200	2036
+#endif
 #define MID_AntiAlias	2005
 #define MID_Next	2006
 #define MID_Prev	2007
@@ -1646,6 +1653,9 @@
 #define MID_FontCompare	2239
 #define MID_CanonicalStart	2242
 #define MID_CanonicalContours	2243
+#ifdef FONTFORGE_CONFIG_CLWFK
+#define MID_ExpandJointDef	2290
+#endif
 #define MID_Center	2600
 #define MID_Thirds	2601
 #define MID_SetWidth	2602
@@ -3958,7 +3968,7 @@
 #elif defined(FONTFORGE_CONFIG_GTK)
 	    static char *buts[] = { GTK_STOCK_YES, GTK_STOCK_NO, NULL };
 #endif
-	    if ( gwwv_ask(U_("Replace Å"),(const char **) buts,0,1,U_("Are you sure you want to replace Å?\nThe ring will not join to the A."))==1 )
+	    if ( gwwv_ask(U_("Replace "),(const char **) buts,0,1,U_("Are you sure you want to replace ?\nThe ring will not join to the A."))==1 )
     continue;
 	}
 	if ( SFIsSomethingBuildable(fv->sf,sc,onlyaccents) ) {
@@ -4770,6 +4780,12 @@
 	default_fv_font_size = dspsize = 72;
     else if ( mi->mid == MID_96 )
 	default_fv_font_size = dspsize = 96;
+#ifdef FONTFORGE_CONFIG_HUGE_FONTVIEW
+    else if ( mi->mid == MID_120 )
+	default_fv_font_size = dspsize = 120;
+    else if ( mi->mid == MID_200 )
+	default_fv_font_size = dspsize = 200;
+#endif
     else if ( mi->mid == MID_FitToEm ) {
 # elif defined(FONTFORGE_CONFIG_GTK)
 void FontViewMenu_PixelSize(GtkMenuItem *menuitem, gpointer user_data) {
@@ -4789,6 +4805,12 @@
 	default_fv_font_size = dspsize = 72;
     else if ( strstr(name,"96")!=NULL )
 	default_fv_font_size = dspsize = 96;
+#ifdef FONTFORGE_CONFIG_HUGE_FONTVIEW
+    else if ( strstr(name,"120")!=NULL )
+	default_fv_font_size = dspsize = 120;
+    else if ( strstr(name,"200")!=NULL )
+	default_fv_font_size = dspsize = 200;
+#endif
     else if ( strcmp(name,"fit_to_em1")==0 ) {
 # endif
 	default_fv_bbsized = fv->bbsized = !fv->bbsized;
@@ -6627,6 +6649,32 @@
     { NULL }
 };
 
+#ifdef FONTFORGE_CONFIG_CLWFK
+static void ExpandJointDef(SplineChar *sc, int enc) {
+    char *jointdef = u2utf8_copy(sc->clwfk.jointdef);
+//    SCAddDependents(sc, jointdef, "gothic");
+//    SFAddSkelChar(sc->parent, jointdef);
+    SFAddOneCharFromSkeleton(sc->parent, enc, jointdef);
+    free(jointdef);
+}
+
+static void FVExpandJointDef(GWindow gw, struct gmenuitem *mi, GEvent *e) {
+    FontView *fv = (FontView *) GDrawGetUserData(gw);
+    int i;
+
+    for (i = 0; i < fv->sf->glyphcnt; i++) {
+	SplineChar *sc = fv->sf->glyphs[i];
+	if (fv->selected[i] && sc!=NULL && sc->clwfk.jointdef!=NULL ) {
+	    SCClearBackground(sc);
+	    SplinePointListsFree(sc->layers[ly_fore].splines);
+	    ExpandJointDef(sc, i);
+	    SCCharChangedUpdate(sc);
+	}
+    }
+  
+}
+#endif
+
 static GMenuItem ellist[] = {
     { { (unichar_t *) N_("_Font Info..."), NULL, COLOR_DEFAULT, COLOR_DEFAULT, NULL, NULL, 0, 0, 0, 0, 0, 0, 1, 1, 0, 'F' }, 'F', ksm_control|ksm_shift, NULL, NULL, FVMenuFontInfo },
     { { (unichar_t *) N_("Glyph _Info..."), NULL, COLOR_DEFAULT, COLOR_DEFAULT, NULL, NULL, 0, 0, 0, 0, 0, 0, 1, 1, 0, 'I' }, 'I', ksm_control, NULL, NULL, FVMenuCharInfo, MID_CharInfo },
@@ -6654,6 +6702,9 @@
     { { (unichar_t *) N_("_Correct Direction"), NULL, COLOR_DEFAULT, COLOR_DEFAULT, NULL, NULL, 0, 0, 0, 0, 0, 0, 1, 1, 0, 'D' }, 'D', ksm_control|ksm_shift, NULL, NULL, FVMenuCorrectDir, MID_Correct },
     { { NULL, NULL, COLOR_DEFAULT, COLOR_DEFAULT, NULL, NULL, 0, 0, 0, 0, 0, 1, 0, 0, }},
     { { (unichar_t *) N_("B_uild"), NULL, COLOR_DEFAULT, COLOR_DEFAULT, NULL, NULL, 0, 0, 0, 0, 0, 0, 1, 1, 0, 'B' }, '\0', ksm_control|ksm_shift, balist, balistcheck, NULL, MID_BuildAccent },
+#ifdef FONTFORGE_CONFIG_CLWFK
+    { { (unichar_t *) N_("_Joint Def:"), NULL, COLOR_DEFAULT, COLOR_DEFAULT, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 1, 0, 'J' }, '\0', ksm_control|ksm_shift, NULL, NULL, FVExpandJointDef, MID_ExpandJointDef },
+#endif
     { { NULL, NULL, COLOR_DEFAULT, COLOR_DEFAULT, NULL, NULL, 0, 0, 0, 0, 0, 1, 0, 0, }},
     { { (unichar_t *) N_("_Merge Fonts..."), NULL, COLOR_DEFAULT, COLOR_DEFAULT, NULL, NULL, 0, 0, 0, 0, 0, 0, 1, 1, 0, 'M' }, '\0', ksm_control|ksm_shift, NULL, NULL, FVMenuMergeFonts, MID_MergeFonts },
     { { (unichar_t *) N_("Interpo_late Fonts..."), NULL, COLOR_DEFAULT, COLOR_DEFAULT, NULL, NULL, 0, 0, 0, 0, 0, 0, 1, 1, 0, 'p' }, '\0', ksm_control|ksm_shift, NULL, NULL, FVMenuInterpFonts, MID_InterpolateFonts },
@@ -7354,6 +7405,10 @@
     { { (unichar_t *) N_("_48 pixel outline"), NULL, COLOR_DEFAULT, COLOR_DEFAULT, NULL, NULL, 0, 0, 1, 0, 0, 0, 1, 1, 0, '4' }, '4', ksm_control, NULL, NULL, FVMenuSize, MID_48 },
     { { (unichar_t *) N_("_72 pixel outline"), NULL, COLOR_DEFAULT, COLOR_DEFAULT, NULL, NULL, 0, 0, 1, 0, 0, 0, 1, 1, 0, '4' }, '7', ksm_control, NULL, NULL, FVMenuSize, MID_72 },
     { { (unichar_t *) N_("_96 pixel outline"), NULL, COLOR_DEFAULT, COLOR_DEFAULT, NULL, NULL, 0, 0, 1, 0, 0, 0, 1, 1, 0, '4' }, '9', ksm_control, NULL, NULL, FVMenuSize, MID_96 },
+#ifdef FONTFORGE_CONFIG_HUGE_FONTVIEW
+    { { (unichar_t *) N_("120 pixel outline"), NULL, COLOR_DEFAULT, COLOR_DEFAULT, NULL, NULL, 0, 0, 1, 0, 0, 0, 1, 1, 0, '4' }, '8', ksm_control, NULL, NULL, FVMenuSize, MID_120 },
+    { { (unichar_t *) N_("200 pixel outline"), NULL, COLOR_DEFAULT, COLOR_DEFAULT, NULL, NULL, 0, 0, 1, 0, 0, 0, 1, 1, 0, '4' }, '\0', ksm_control, NULL, NULL, FVMenuSize, MID_200 },
+#endif
     { { (unichar_t *) N_("_Anti Alias"), NULL, COLOR_DEFAULT, COLOR_DEFAULT, NULL, NULL, 0, 0, 1, 0, 0, 0, 1, 1, 0, 'A' }, '5', ksm_control, NULL, NULL, FVMenuSize, MID_AntiAlias },
     { { (unichar_t *) N_("_Fit to em"), NULL, COLOR_DEFAULT, COLOR_DEFAULT, NULL, NULL, 0, 0, 1, 0, 0, 0, 1, 1, 0, 'F' }, '6', ksm_control, NULL, NULL, FVMenuSize, MID_FitToEm },
     { NULL },			/* Some extra room to show bitmaps */
@@ -7470,6 +7525,16 @@
 	    mi->ti.checked = (fv->show!=NULL && fv->show==fv->filled && fv->show->pixelsize==96);
 	    mi->ti.disabled = sf->onlybitmaps && fv->show!=fv->filled;
 	  break;
+#ifdef FONTFORGE_CONFIG_HUGE_FONTVIEW
+	  case MID_120:
+	    mi->ti.checked = (fv->show!=NULL && fv->show==fv->filled && fv->show->pixelsize==120);
+	    mi->ti.disabled = fv->sf->onlybitmaps && fv->show!=fv->filled;
+	  break;
+	  case MID_200:
+	    mi->ti.checked = (fv->show!=NULL && fv->show==fv->filled && fv->show->pixelsize==200);
+	    mi->ti.disabled = fv->sf->onlybitmaps && fv->show!=fv->filled;
+	  break;
+#endif
 	  case MID_AntiAlias:
 	    mi->ti.checked = (fv->show!=NULL && fv->show->clut!=NULL);
 	    mi->ti.disabled = sf->onlybitmaps && fv->show!=fv->filled;
@@ -9196,7 +9261,11 @@
 		uni = amspua[uni-0xe000];
 	    switch ( fv->glyphlabel ) {
 	      case gl_name:
+#ifdef FONTFORGE_CONFIG_CLWFK
+		utf82u_strncpy(buf,sc->name,sizeof(buf)/sizeof(buf[0]));
+#else
 		uc_strncpy(buf,sc->name,sizeof(buf)/sizeof(buf[0]));
+#endif
 		styles = _uni_sans;
 	      break;
 	      case gl_unicode:
@@ -9419,7 +9488,7 @@
 		GDrawDrawRect(pixmap,&box,0xff0000);
 		++box.x; ++box.y; box.width -= 2; box.height -= 2;
 		GDrawDrawRect(pixmap,&box,0xff0000);
-/* When reencoding a font we can find times where index>=show->charcnt */
+/* When reencoding a font we can find times where index>=show->glyphcnt */
 	    } else if ( fv->show!=NULL && feat_gid<fv->show->glyphcnt && feat_gid!=-1 &&
 		    fv->show->glyphs[feat_gid]!=NULL ) {
 		bdfc = fv->show->glyphs[feat_gid];
@@ -9658,6 +9727,24 @@
 	if ( index<0 ) index = 9;
 	if ( script_filenames[index]!=NULL )
 	    ExecuteScriptFile(fv,script_filenames[index]);
+#ifdef FONTFORGE_CONFIG_CLWFK
+    } else if ( (event->u.chr.keysym=='$' || event->u.chr.keysym=='%') &&
+		(event->u.chr.state&ksm_control) ) {
+        int pos = FVAnyCharSelected(fv);
+	if ( pos>=0 && fv->sf->glyphs[pos]!=NULL ) {
+	    SCClearBackground(fv->sf->glyphs[pos]);
+	    SCFleshSkeleton(fv->sf->glyphs[pos], (event->u.chr.keysym=='$')?"mincho":"gothic",
+			    CVShows.normkanji);
+	} else if ( pos==-2 ) {
+	    for ( i=0; i<fv->sf->glyphcnt; i++ ) {
+		if (fv->selected[i]) {
+		    SCClearBackground(fv->sf->glyphs[i]);
+		    SCFleshSkeleton(fv->sf->glyphs[i], (event->u.chr.keysym=='$'?"mincho":"gothic"),
+				    CVShows.normkanji);
+		}
+	    }
+	}
+#endif
     } else if ( event->u.chr.keysym == GK_Left ||
 	    event->u.chr.keysym == GK_Tab ||
 	    event->u.chr.keysym == GK_BackTab ||
@@ -10836,6 +10923,10 @@
 	sf = SFReadPdfFont(fullname,openflags);
     } else if ( strmatch(fullname+strlen(fullname)-3, ".ik")==0 && checked!='i' ) {
 	sf = SFReadIkarus(fullname);
+#ifdef FONTFORGE_CONFIG_CLWFK
+    } else if ( strmatch(fullname+strlen(fullname)-2, ".l")==0 ) {
+      sf = SFReadClwfkSkeleton(fullname);
+#endif
     } else {
 	sf = SFReadMacBinary(fullname,0,openflags);
     }
@@ -10941,7 +11032,11 @@
     FontView *fv;
     SplineFont *sf;
     char *pt, *ept, *tobefreed1=NULL, *tobefreed2=NULL;
-    static char *extens[] = { ".sfd", ".pfa", ".pfb", ".ttf", ".otf", ".ps", ".cid", ".bin", ".dfont", ".PFA", ".PFB", ".TTF", ".OTF", ".PS", ".CID", ".BIN", ".DFONT", NULL };
+    static char *extens[] = { ".sfd", ".pfa", ".pfb", ".ttf", ".otf", ".ps", ".cid", ".bin", ".dfont", ".PFA", ".PFB", ".TTF", ".OTF", ".PS", ".CID", ".BIN", ".DFONT", 
+#ifdef FONTFORGE_CONFIG_CLWFK
+			      ".l", ".L",
+#endif
+			      NULL };
     int i;
 
     if ( filename==NULL )
--- fontforge/fvfonts.c.orig	Wed Jul 26 01:17:13 2006
+++ fontforge/fvfonts.c	Sun Nov 12 12:01:32 2006
@@ -450,6 +450,8 @@
     val ^= (val>>16);
     val &= 0xffff;
     val %= GN_HSIZE;
+    while ( val < 0 )
+	val += GN_HSIZE;
 return( val );
 }
 
@@ -601,6 +603,14 @@
 			    strcmp(map->enc->psnames[index],name)==0 )
 return( index );
 	    }
+#ifdef FONTFORGE_CONFIG_CLWFK
+	    /* if SFHashName() hashes UTF-8 values properly, this won't be necessary. */
+	    for ( index = map->enccount-1; index>=0; --index )
+		if ( sf->glyphs[index]!=NULL && 
+		     sf->glyphs[index]->name!=NULL &&
+		     strcmp(sf->glyphs[index]->name,name)==0 )
+return( map->backmap[index] );
+#endif
 	}
     }
 
--- fontforge/pfaeditui.h.orig	Fri Jan 13 11:25:45 2006
+++ fontforge/pfaeditui.h	Wed Mar 22 13:33:09 2006
@@ -31,6 +31,9 @@
 
 extern void help(char *filename);
 extern int FontForgeMain( int argc, char **argv );
+#ifdef FONTFORGE_CONFIG_CLWFK
+extern int FontForgeMainWithNoArgs( void );
+#endif
 
 #if defined(FONTFORGE_CONFIG_GTK)
 # include <gtk/gtk.h>
--- fontforge/problems.c.orig	Tue Aug 22 13:49:46 2006
+++ fontforge/problems.c	Sun Nov 12 12:02:56 2006
@@ -77,6 +77,14 @@
     unsigned int doneexplain: 1;
     unsigned int finish: 1;
     unsigned int ignorethis: 1;
+#ifdef FONTFORGE_CONFIG_CLWFK
+    unsigned int strokeendpts: 1;
+    unsigned int danglinglink: 1;
+    unsigned int primnames: 1;
+#if 0	/* not yet implemented */
+    unsigned int kamaetype: 1;
+#endif
+#endif
     double near, xval, yval, widthval;
     char *explaining;
     double found, expected;
@@ -3310,3 +3318,74 @@
 	GDrawDestroyWindow(p.explainw);
 }
 #endif		/* FONTFORGE_CONFIG_NO_WINDOWING_UI */
+
+#ifdef FONTFORGE_CONFIG_CLWFK
+static int SplEdgeCount(SplinePointList *spl) {
+    int cnt;
+    SplinePoint *first = spl->first, *sp;
+    Spline *spline;
+
+    if ( first==NULL )
+return( 0 );
+    cnt = 1;
+    for ( spline=first->next; spline!=NULL && spline->to!=first; spline=spline->to->next ) {
+        sp = spline->to;
+	if ( sp==NULL )
+	    spline = NULL;
+	else if ( sp->next==NULL || !sp->islinkpt )
+	    cnt++;
+    }
+return( cnt );
+}
+
+static int CheckStrokeEdgeCount(SplineChar *sc) {
+    SplinePointList *spl;
+    int good = true;
+    int cnt, correct_cnt;
+
+    for ( spl=sc->layers[ly_fore].splines; spl!=NULL; spl=spl->next ) {
+	cnt = SplEdgeCount(spl);
+	correct_cnt = num_edges_in_strokes[spl->stroketype];
+	if ( cnt < correct_cnt ) {
+	    fprintf(stderr, 
+		    "Failed to export skeleton, because %s needs %d edges but there are %d.\n",
+		    stroketypes[spl->stroketype], correct_cnt, cnt);
+	    GWidgetError8(_("Bad Skeleton"),
+			  _("Failed to export skeleton, because\n%s needs %d points but there are %d"),
+			  u_stroketypes[spl->stroketype], correct_cnt, cnt);
+return( good = false );
+	}
+    }
+return( good );
+}
+
+static int CheckSkeletonNames(SplineChar *sc) {
+    int enc, good = true;
+    RefChar *ref;
+
+    if (sc->name == NULL) {
+	fprintf(stderr, 
+		"You must name your skeleton to export. Set in [CLWFK] pane of Glyph Info\n");
+return ( good = false );
+    }
+    for ( ref = sc->layers[ly_fore].refs; ref!=NULL; ref=ref->next ) {
+	enc = SFFindGID(sc->parent, -1, ref->sc->name);
+	if (enc < 0 || enc > sc->parent->glyphcnt) {
+	    fprintf(stderr, "Char named %s does not exist in this font.\n", ref->sc->name);
+return( good = false );
+	} else {
+	    good = SkeletonCheck(sc->parent->glyphs[enc]);
+	    if ( !good )
+return( good = false );
+	}
+    }
+return ( good );
+}
+
+int SkeletonCheck(SplineChar *sc) {
+    int good;
+    good = (CheckStrokeEdgeCount(sc) && CheckSkeletonNames(sc));
+		
+return ( good );
+}
+#endif
--- fontforge/savefontdlg.c.orig	Thu Sep 28 05:50:34 2006
+++ fontforge/savefontdlg.c	Sun Nov 12 12:04:50 2006
@@ -96,7 +96,11 @@
 	".cid", ".cff", ".cid.cff",
 	".t42", ".cid.t42",
 	".ttf", ".ttf", ".suit", ".dfont", ".otf", ".otf.dfont", ".otf",
+#ifdef FONTFORGE_CONFIG_CLWFK
+	".otf.dfont", ".svg", ".l", NULL };
+#else
 	".otf.dfont", ".svg", NULL };
+#endif
 # ifndef FONTFORGE_CONFIG_NO_WINDOWING_UI
 static char *bitmapextensions[] = { "-*.bdf", ".ttf", ".dfont", ".ttf", ".otb", ".bmap", ".dfont", ".fon", "-*.fnt", ".pdb", "-*.pt3", ".none", NULL };
 # endif
@@ -105,7 +109,11 @@
 	".cid", ".cff", ".cid.cff",
 	".t42", ".cid.t42",
 	".ttf", ".ttf", ".ttf.bin", ".dfont", ".otf", ".otf.dfont", ".otf",
+#ifdef FONTFORGE_CONFIG_CLWFK
+	".otf.dfont", ".svg", ".l", NULL };
+#else
 	".otf.dfont", ".svg", NULL };
+#endif
 # ifndef FONTFORGE_CONFIG_NO_WINDOWING_UI
 static char *bitmapextensions[] = { "-*.bdf", ".ttf", ".dfont", ".ttf", ".otb", ".bmap.bin", ".fon", "-*.fnt", ".pdb", "-*.pt3", ".none", NULL };
 # endif
@@ -146,6 +154,9 @@
     { (unichar_t *) N_("OpenType CID"), NULL, 0, 0, NULL, NULL, 1, 0, 0, 0, 0, 0, 1 },
     { (unichar_t *) N_("OpenType CID (dfont)"), NULL, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 1 },
     { (unichar_t *) N_("SVG font"), NULL, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 1 },
+#ifdef FONTFORGE_CONFIG_CLWFK
+    { (unichar_t *) N_("CLWFK Skeleton"), NULL, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 1 },
+#endif
     { (unichar_t *) N_("No Outline Font"), NULL, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 1 },
     { NULL }
 };
@@ -1371,6 +1382,30 @@
 }
 #endif
 
+#ifdef FONTFORGE_CONFIG_CLWFK
+static int WriteCLWFKSkeleton(char *fontname, SplineFont *sf, enum fontformat format, int flags) {
+    FILE *file;
+    int i, ret;
+
+    if (( file=fopen(fontname,"w"))==NULL )
+return( 0 );
+    ret = true;
+    if ( sf->strokewidth > 0 )
+	fprintf(file, "(setq gothicwidth %.2f)\n\n", sf->strokewidth * 0.2);
+    for ( i = 0; i < sf->glyphcnt; i++ ) {
+	if (sf->glyphs[i]!=NULL) {
+	    ret &= ExportSkeleton(file,sf->glyphs[i],true);
+	    fputc('\n', file);
+        }
+    }
+    if ( ferror(file) )
+	ret = false;
+    if ( fclose(file)==-1 )
+        ret = false;
+return( ret );
+}
+#endif
+
 static char *SearchDirForWernerFile(char *dir,char *filename) {
     char buffer[1025], buf2[200];
     FILE *file;
@@ -1937,6 +1972,11 @@
 #endif
 	    oerr = !WriteSVGFont(newname,sf,oldformatstate,flags,map);
 	  break;
+#ifdef FONTFORGE_CONFIG_CLWFK
+	  case ff_clwfk:
+	    oerr = !WriteCLWFKSkeleton(newname,sf,oldformatstate,flags);
+	  break;
+#endif
 	}
 	if ( oerr ) {
 	    gwwv_post_error(_("Save Failed"),_("Save Failed"));
@@ -3140,6 +3180,9 @@
 	formattypes[ff_cff].disabled = true;
 	formattypes[ff_cffcid].disabled = true;
 	formattypes[ff_svg].disabled = true;
+#ifdef FONTFORGE_CONFIG_CLWFK
+	formattypes[ff_clwfk].disabled = true;
+#endif
     }
     for ( i=0; i<sizeof(formattypes)/sizeof(formattypes[0]); ++i )
 	formattypes[i].selected = false;
--- fontforge/scripting.c.orig	Fri Mar 17 11:03:33 2006
+++ fontforge/scripting.c	Fri Mar 17 11:14:25 2006
@@ -4270,6 +4270,24 @@
     FVAutoTrace(c->curfv,false);
 }
 
+#ifdef FONTFORGE_CONFIG_CLWFK
+static void bBuildSkeleton(Context *c) {
+    int i, gid;
+    FontView *fv = c->curfv;
+    SplineFont *sf = fv->sf;
+    EncMap *map = fv->map;
+
+    if ( c->a.argc!=2 || c->a.vals[1].type!=v_str )
+	ScriptError( c, "Bad type for argument" );
+    for ( i=0; i<map->enccount; ++i ) if ( fv->selected[i] ) {
+	gid = map->map[i];
+	SCBuildSkeleton(sf->glyphs[gid], c->a.vals[1].u.sval);
+return;
+    }
+    ScriptError( c, "No glyph selected" );
+}
+#endif
+
 static void bCorrectDirection(Context *c) {
     int i, gid;
     FontView *fv = c->curfv;
@@ -6620,6 +6638,9 @@
     { "RoundToCluster", bRoundToCluster },
     { "Autotrace", bAutotrace },
     { "AutoTrace", bAutotrace },	/* Oops. docs say upperT, old scripts expect lowert */
+#ifdef FONTFORGE_CONFIG_CLWFK
+    { "BuildSkeleton", bBuildSkeleton },
+#endif
     { "CorrectDirection", bCorrectDirection },
     { "AddATT", bAddATT },
     { "DefaultATT", bDefaultATT },
--- fontforge/sfd.c.orig	Sat Mar 25 06:54:58 2006
+++ fontforge/sfd.c	Mon Apr  3 10:34:44 2006
@@ -28,6 +28,9 @@
 #include "splinefont.h"
 #include "gdraw.h"
 #include "ustring.h"
+#ifdef FONTFORGE_CONFIG_CLWFK
+#include "views.h"	/* for SFAddGlyphAndEncode */
+#endif
 #include <math.h>
 #include <utype.h>
 #include <unistd.h>
@@ -561,7 +564,15 @@
 			(sp->nextcpdef<<3)|(sp->prevcpdef<<4)|
 			(sp->roundx<<5)|(sp->roundy<<6)|
 			(sp->ttfindex==0xffff?(1<<7):0)|
+#ifdef FONTFORGE_CONFIG_CLWFK
+			(sp->locked<<9)|(sp->islinkpt<<10)|
+#endif
 			(sp->dontinterpolate<<8) );
+#ifdef FONTFORGE_CONFIG_CLWFK
+	    /* this makes SFD file incompatible. to open with regular FF, apply 'sed s%#[a-z0-9-]*##' */
+	    if ( first==NULL )
+		fprintf( sfd, "#%s", stroketypes[spl->stroketype] );
+#endif
 	    if ( order2 ) {
 		if ( sp->ttfindex!=0xfffe && sp->nextcpindex!=0xfffe ) {
 		    putc(',',sfd);
@@ -2369,11 +2380,23 @@
 		pt->ttfindex = 0xffff;
 	    else
 		pt->ttfindex = ttfindex++;
+#ifdef FONTFORGE_CONFIG_CLWFK
+	    pt->locked = val&0x200?1:0;
+	    pt->islinkpt = val&0x400?1:0;
+#endif
 	    pt->nextcpindex = 0xfffe;
 	    ch = getc(sfd);
 	    if ( ch=='x' ) {
 		pt->hintmask = chunkalloc(sizeof(HintMask));
 		SFDGetHintMask(sfd,pt->hintmask);
+#ifdef FONTFORGE_CONFIG_CLWFK
+	    } else if ( ch=='#' ) {
+		int type;
+		getname(sfd,tok);
+		for (type=0; type<num_enum_stroke; type++)
+		    if (strcmp(stroketypes[type],tok)==0)
+			cur->stroketype = type;
+#endif
 	    } else if ( ch!=',' )
 		ungetc(ch,sfd);
 	    else {
@@ -4861,10 +4884,10 @@
 #endif
     break;
 	} else if ( strmatch(tok,"BeginChars:")==0 ) {
-	    int charcnt;
-	    getint(sfd,&charcnt);
+	    int glyphcnt;
+	    getint(sfd,&glyphcnt);
 	    if ( getint(sfd,&realcnt)!=1 || realcnt==-1 )
-		realcnt = charcnt;
+		realcnt = glyphcnt;
 	    else
 		++realcnt;		/* value saved is max glyph, not glyph cnt */
 #if defined(FONTFORGE_CONFIG_GDRAW)
@@ -4877,10 +4900,10 @@
 	    if ( cidmaster!=NULL ) {
 		sf->map = cidmaster->map;
 	    } else {
-		sf->map = EncMapNew(charcnt,realcnt,enc);
+		sf->map = EncMapNew(glyphcnt,realcnt,enc);
 		sf->map->remap = remap;
 	    }
-	    SFDSizeMap(sf->map,sf->glyphcnt,charcnt);
+	    SFDSizeMap(sf->map,sf->glyphcnt,glyphcnt);
     break;
 #if HANYANG
 	} else if ( strmatch(tok,"BeginCompositionRules")==0 ) {
@@ -5336,3 +5359,975 @@
     fclose(sfd);
 return( ret );
 }
+
+#ifdef FONTFORGE_CONFIG_CLWFK
+const char *stroketypes[num_enum_stroke] = {
+    "ten", "tate", "yoko", "migiue", "hidari", "tatehidari", "migi",
+    "kozato", "tatehane", "tsukurihane", "sanzui", "kokoro", "tasuki", 
+    "shin-nyuu", "magaritate", "kagi",
+    "hira-long",
+    "kamae", "kamae1", "kamae2", "nyou", "tare",
+};
+const int num_edges_in_strokes[num_enum_stroke] = {
+    2, 2, 2, 3, 3, 4, 3,
+    4, 3, 4, 2, 4, 4, 
+    3, 3, 3,
+    0,
+    -4, -4, -4, -4, -4,
+};
+
+static const unichar_t u_sk_ten[] = { 't','e','n','\0' };
+static const unichar_t u_sk_tate[] = { 't','a','t','e','\0' };
+static const unichar_t u_sk_yoko[] = { 'y','o','k','o','\0' };
+static const unichar_t u_sk_migiue[] = { 'm','i','g','i','u','e','\0' };
+static const unichar_t u_sk_hidari[] = { 'h','i','d','a','r','i','\0' };
+static const unichar_t u_sk_tatehidari[] = { 't','a','t','e','h','i','d','a','r','i','\0' };
+static const unichar_t u_sk_migi[] = { 'm','i','g','i','\0' };
+static const unichar_t u_sk_kozato[] = { 'k','o','z','a','t','o','\0' };
+static const unichar_t u_sk_tatehane[] = { 't','a','t','e','h','a','n','e','\0' };
+static const unichar_t u_sk_tsukurihane[] = { 't','s','u','k','u','r','i','h','a','n','e','\0' };
+static const unichar_t u_sk_sanzui[] = { 's','a','n','z','u','i','\0' };
+static const unichar_t u_sk_kokoro[] = { 'k','o','k','o','r','o','\0' };
+static const unichar_t u_sk_tasuki[] = { 't','a','s','u','k','i','\0' };
+static const unichar_t u_sk_shin_nyuu[] = { 's','h','i','n','-','n','y','u','u','\0' };
+static const unichar_t u_sk_magaritate[] = { 'm','a','g','a','r','i','t','a','t','e','\0' };
+static const unichar_t u_sk_kagi[] = { 'k','a','g','i','\0' };
+static const unichar_t u_sk_hira_long[] = { 'h','i','r','a','-','l','o','n','g','\0' };
+static const unichar_t u_sk_kamae[] = { 'k','a','m','a','e','\0' };
+static const unichar_t u_sk_kamae1[] = { 'k','a','m','a','e','1','\0' };
+static const unichar_t u_sk_kamae2[] = { 'k','a','m','a','e','2','\0' };
+static const unichar_t u_sk_nyou[] = { 'n','y','o','u','\0' };
+static const unichar_t u_sk_tare[] = { 't','a','r','e','\0' };
+
+const unichar_t *u_stroketypes[num_enum_stroke] = {
+    u_sk_ten, u_sk_tate, u_sk_yoko, u_sk_migiue, u_sk_hidari, u_sk_tatehidari, u_sk_migi,
+    u_sk_kozato, u_sk_tatehane, u_sk_tsukurihane, u_sk_sanzui, u_sk_kokoro, u_sk_tasuki, 
+    u_sk_shin_nyuu, u_sk_magaritate, u_sk_kagi,
+    u_sk_hira_long,
+    u_sk_kamae, u_sk_kamae1, u_sk_kamae2, u_sk_nyou, u_sk_tare,
+};
+
+enum skeltype { skel_prim, skel_combo, skel_stroke_template, };
+
+typedef struct skelpoint {
+    real x, y;
+    unsigned int link_ok:1;
+} SkelPoint;
+
+typedef struct skelstroke {
+    enum stroke stroke_type;
+    int num_points;
+    short point_index[32];
+    unsigned int is_link;	/* bit (1<<n) correspoinds to point_index[n]  */
+    real width;
+} SkelStroke;
+
+typedef real transform_matrix[6];
+
+typedef struct skelchar {
+    char *name;
+    enum skeltype type;
+    int num_points;
+    SkelPoint *points;
+    int num_strokes;
+    SkelStroke *strokes;
+    SkelParams extra;
+    DBounds kamaes[7];
+    int num_refs;
+    transform_matrix *matrice;
+    char **subskel_names;
+    char *orig_def;
+    int expanded;
+} SkelChar;
+
+typedef struct skelchars {
+    SkelChar *skel[256];
+    struct skelchars *next;
+} SkelChars;
+
+typedef struct skelinfo {
+    int num_skel;
+    real gothicwidth;
+    real minchowidth;
+    SkelChars *chars;
+} SkelInfo;
+
+#undef LISP_OUTPUT_LOG
+
+static void skipLine(FILE *file) {
+    int c;
+
+    while ( (c=getc(file)) != EOF && c!='\n' )
+	;
+}
+
+static void skipComment(FILE *file) {
+    int c;
+
+    while ((c=getc(file)) == ';') {
+	skipLine(file);
+    }
+    if (c != EOF)
+	ungetc(c,file);
+}
+
+static void skipSpaces(FILE *file) {
+    int c;
+
+    for (skipComment(file); isspace(c=getc(file)); )
+	skipComment(file);
+    if (c != EOF)
+	ungetc(c,file);
+}
+
+static int charExists(FILE *file, int expected) {
+    int c = getc(file);
+
+#ifdef LISP_OUTPUT_LOG
+    fprintf(stderr,"charExists: '%c' (expected '%c')\n", c, expected);
+#endif
+    if (c==expected)
+return true;
+    if (c!=EOF)
+	ungetc(c,file);
+return false;
+}
+
+static int tokCharExists(FILE *file, int expected) {
+    skipSpaces(file);
+return charExists(file, expected);
+}
+
+
+static int openParenExists(FILE *file) {
+    return tokCharExists(file, '(');
+}
+
+static int closeParenExists(FILE *file) {
+    return tokCharExists(file, ')');
+}
+
+enum lisptoktype { lisp_open_paren, lisp_close_paren, lisp_quote, lisp_igeta, lisp_dot, 
+		   lisp_name, lisp_numeral, lisp_string, lisp_none };
+
+static enum lisptoktype lispTokenType(char *buf) {
+    switch (*buf) {
+    case '(':
+return lisp_open_paren;
+    case ')':
+return lisp_close_paren;
+    case '\'':
+return lisp_quote;
+    case '#':
+return lisp_igeta;
+    case '\"':
+return lisp_string;
+    case '0': case '1': case '2': case '3': case '4':
+    case '5': case '6': case '7': case '8': case '9':
+return lisp_numeral;
+    case '+': case '-':
+	if (isdigit(buf[1]))
+return lisp_numeral;
+	else
+return lisp_name;
+    case '.': 
+	if (isdigit(buf[1]))
+return lisp_numeral;
+	else
+return lisp_dot;
+    case '\0':
+return lisp_none;
+    default:
+return lisp_name;
+    }
+}
+
+static int isLispNameToken(char *buf) {
+    return (lispTokenType(buf)==lisp_name);
+}
+
+#ifdef LISP_OUTPUT_LOG
+static char *_getToken(FILE *file, char *buf, int bufsize) {
+#else
+static char *getToken(FILE *file, char *buf, int bufsize) {
+#endif
+    int c;
+    char *p = buf;
+    enum lisptoktype type = lisp_none;
+
+    bzero(buf,bufsize);
+    while ( (c=getc(file)) != EOF ) {
+	*p = c;
+	if ( type==lisp_none ) {
+	    if ( c == ';' ) {
+		skipLine(file);
+continue;
+	    } else if ( isspace(c) ) {
+continue;
+	    }
+	    if ( c=='(' || c==')' || c=='\'' )
+return buf;
+
+	}
+	type = lispTokenType(buf);
+
+	if ( type==lisp_string) {
+	    if (c == '\"') {
+		p++;
+break;
+	    }
+	} else if (type==lisp_numeral) {
+	    if (!isdigit(c) && c!= '.' && c!='+' && c!='-' && c!='e') {
+		ungetc(c, file);
+		*p = '\0';
+return buf;
+	    }
+	} else if ( (c<128&&isspace(c)) || c=='(' || c==')' || c=='\'' || c=='\"' ) {
+	    ungetc(c, file);
+	    *p = '\0';
+return buf;
+	}
+	p++;
+    }
+    if (type == lisp_name)
+	ungetc(*p, file);
+    *p = '\0';
+    return buf;
+}
+
+#ifdef LISP_OUTPUT_LOG
+static char *getToken(FILE *file, char *buf, int bufsize) {
+    static char *p;
+    p = _getToken(file,buf,bufsize);
+    if (p)
+      fprintf(stderr, "gettoken: %s\n",p);
+    return p;
+}
+#endif
+
+static char *getNumeral(FILE *file, char *buf, int bufsize) {
+    if (getToken(file,buf,bufsize)==NULL || lispTokenType(buf)!=lisp_numeral)
+return NULL;
+    else
+return buf;
+}
+
+static int nameExists(FILE *file, char *buf,int bufsize, char *name) {
+    if (getToken(file,buf,bufsize)==NULL || lispTokenType(buf)!=lisp_name ||
+	strcasecmp(buf,name)!=0)
+return false;
+    else
+return true;
+}
+
+static int someNameExists(FILE *file, char *buf,int bufsize) {
+    if (getToken(file,buf,bufsize)==NULL || lispTokenType(buf)!=lisp_name)
+return false;
+    else
+return true;
+}
+
+static SkelChar *SkelCharReadPoints(FILE *file,SkelChar *sc,char *buf,int bufsize) {
+    static SkelPoint pbuf[512];
+    int i = 0;
+
+    if (!openParenExists(file))
+return NULL;
+    while (openParenExists(file)) {
+	if (i >= (sizeof(pbuf)/sizeof(pbuf[0])) || getNumeral(file,buf,bufsize) == NULL)
+return NULL;
+	pbuf[i].x = strtod(buf,NULL);
+	if (getNumeral(file,buf,bufsize) == NULL)
+return NULL;
+	pbuf[i].y = strtod(buf,NULL);
+	pbuf[i].link_ok = openParenExists(file);
+	if (pbuf[i].link_ok)
+	    if (!nameExists(file,buf,bufsize,"link-ok") || !nameExists(file,buf,bufsize,"t") ||
+		!closeParenExists(file))
+return NULL;
+	if (!closeParenExists(file))
+return NULL;
+	i++;
+    }
+    if (!closeParenExists(file))
+return NULL;
+
+    sc->num_points = i;
+    if ((sc->points=gcalloc(i,sizeof(SkelPoint))) == NULL)
+return NULL;
+    memcpy(sc->points,pbuf,i*sizeof(SkelPoint));
+return sc;
+}
+
+static int primType(const char *buf) {
+    int i;
+
+    for (i = 0; i<num_enum_stroke; i++)
+        if (strcasecmp(buf, stroketypes[i])==0)
+return i;
+return -1;
+}
+
+
+static SkelChar *SkelCharReadStrokes(FILE *file,SkelChar *sc,char *buf,int bufsize) {
+    static SkelStroke sbuf[256];
+    int s = 0, p;	/* count of stroke and point (in the stroke) */
+    int type;
+    int link_found;	/* only first (link ...) is recognized */
+
+    if (!openParenExists(file))
+return NULL;
+    while (openParenExists(file)) {
+	if (getToken(file,buf,bufsize) == NULL)
+return NULL;
+	type = primType(buf);
+	if (type < 0)
+return NULL;
+	else if (type < sk_kamae) {
+	    sbuf[s].stroke_type = type;
+	    if (!openParenExists(file))
+return NULL;
+	    for (p = 0; !closeParenExists(file); p++) {
+		if (getNumeral(file,buf,bufsize) == NULL)
+return NULL;
+		sbuf[s].point_index[p] = strtod(buf,NULL);
+	    }
+	    sbuf[s].num_points = p;
+	    sbuf[s].is_link = 0;
+	    link_found = false;
+	    while (openParenExists(file)) {
+		if (getToken(file,buf,bufsize) == NULL)
+return NULL;
+		if (strcasecmp(buf, "link")==0) {
+		    for (; !closeParenExists(file); p++) {
+			if (getNumeral(file,buf,bufsize) == NULL)
+return NULL;
+			if ( !link_found ) {
+			    sbuf[s].point_index[p] = strtod(buf,NULL);
+			    sbuf[s].num_points = p + 1;
+			    sbuf[s].is_link |= (1<<p);
+			    link_found = true;
+			}
+		    }
+		} else if (strcasecmp(buf,"widthratio") ==0) {
+		    if (!tokCharExists(file,'.') || getNumeral(file,buf,bufsize) == NULL)
+return NULL;
+		    sbuf[s].width = (real)strtod(buf,NULL);
+		    if (!closeParenExists(file))
+return NULL;
+		} else {
+return NULL;
+		}
+	    }
+	}
+	if (!closeParenExists(file))
+return NULL;
+	s++;
+    }
+    if (!closeParenExists(file))
+return NULL;
+
+    sc->num_strokes = s;
+    if ((sc->strokes = gcalloc(s,sizeof(SkelStroke))) == NULL)
+return NULL;
+    memcpy(sc->strokes,sbuf,s*sizeof(SkelStroke));
+return sc;
+}
+
+static int kamaetype(const char *str) {
+    switch (tolower(*str)) {
+    case 'k':
+	if (strcasecmp("kamae",str) == 0)
+return sk_kamae;
+	else if (strcasecmp("kamae1",str) == 0)
+return sk_kamae1;
+	else if (strcasecmp("kamae2",str) == 0)
+return sk_kamae2;
+	else
+return -1;
+    case 'n':
+	if (strcasecmp("nyou",str) == 0)
+return sk_nyou;
+	else
+return -1;
+    case 't':
+	if (strcasecmp("tare",str) == 0)
+return sk_tare;
+    default:
+return -1;
+    }
+}
+
+static SkelChar *SkelCharReadExtraSkelInfo(FILE *file,SkelChar *sc,char *buf,int bufsize) {
+    int type;
+
+    while (openParenExists(file)) {
+	if (getToken(file,buf,sizeof(buf))==NULL || lispTokenType(buf)!=lisp_name)
+return NULL;
+	if (strcasecmp("tateheight",buf)==0) {
+	    if (!tokCharExists(file,'.') || getNumeral(file,buf,bufsize)==NULL)
+return NULL;
+	    sc->extra.tateheight = strtod(buf,NULL);
+	} else if (strcasecmp("yokowidth",buf)==0) {
+	    if (!tokCharExists(file,'.') || getNumeral(file,buf,bufsize)==NULL)
+return NULL;
+	    sc->extra.yokowidth = strtod(buf,NULL);
+	} else if (strcasecmp("xunit",buf)==0) {
+	    if (!tokCharExists(file,'.') || getNumeral(file,buf,bufsize)==NULL)
+return NULL;
+	    sc->extra.xunit = strtod(buf,NULL);
+	} else if (strcasecmp("yunit",buf)==0) {
+	    if (!tokCharExists(file,'.') || getNumeral(file,buf,bufsize)==NULL)
+return NULL;
+	    sc->extra.yunit = strtod(buf,NULL);
+	} else if (strcasecmp("xlimit",buf)==0) {
+	    if (getNumeral(file,buf,bufsize)==NULL)
+return NULL;
+	    sc->extra.xlimit_min = strtod(buf,NULL);
+	    if (getNumeral(file,buf,bufsize)==NULL)
+return NULL;
+	    sc->extra.xlimit_max = strtod(buf,NULL);
+	} else if (strcasecmp("ylimit",buf)==0) {
+	    if (getNumeral(file,buf,bufsize)==NULL)
+return NULL;
+	    sc->extra.ylimit_min = strtod(buf,NULL);
+	    if (getNumeral(file,buf,bufsize)==NULL)
+return NULL;
+	    sc->extra.ylimit_max = strtod(buf,NULL);
+	} else if (strcasecmp("center",buf)==0) {
+	    if (closeParenExists(file)) {
+		ungetc(')',file);
+		sc->extra.center = 200.0;
+	    } else if (!tokCharExists(file,'.') || getNumeral(file,buf,bufsize)==NULL) {
+return NULL;
+	    } else
+		sc->extra.center = strtod(buf,NULL);
+	} else if (strcasecmp("width",buf)==0) {
+	    if (!tokCharExists(file,'.') || getNumeral(file,buf,bufsize)==NULL)
+return NULL;
+	    sc->extra.width = strtod(buf,NULL);
+	} else if (strcasecmp("updown",buf)==0) {
+	    if (getNumeral(file,buf,bufsize)==NULL)
+return NULL;
+	    sc->extra.up = strtod(buf,NULL);
+	    if (!tokCharExists(file,'.') || getNumeral(file,buf,bufsize)==NULL)
+return NULL;
+	    sc->extra.down = strtod(buf,NULL);
+	} else if ((type = kamaetype(buf)) > 0) {
+	    if (getNumeral(file,buf,bufsize)==NULL)
+return NULL;
+	    sc->kamaes[type-sk_kamae].minx = (real)strtod(buf,NULL);
+	    if (getNumeral(file,buf,bufsize)==NULL)
+return NULL;
+	    sc->kamaes[type-sk_kamae].miny = (real)strtod(buf,NULL);
+	    if (getNumeral(file,buf,bufsize)==NULL)
+return NULL;
+	    sc->kamaes[type-sk_kamae].maxx = (real)strtod(buf,NULL);
+	    if (getNumeral(file,buf,bufsize)==NULL)
+return NULL;
+	    sc->kamaes[type-sk_kamae].maxy = (real)strtod(buf,NULL);
+	} else
+return NULL;
+	if (!closeParenExists(file))
+return NULL;
+    }
+return sc;
+}
+
+static void *fileError(FILE *file, char *msg) {
+    fprintf(stderr, "%sfile error at byte %ld\n", msg, ftell(file));
+    return NULL;
+}
+
+static SkelChar *getPrimCharOrTateYoko(FILE *file, SkelChar *sk, char *buf, int bufsize) {
+    if (!tokCharExists(file, '\'') || !openParenExists(file) || 
+	getToken(file,buf,sizeof(buf))==NULL) 
+return NULL;
+    if (*buf == '(') {
+	ungetc('(',file);
+	if (SkelCharReadPoints(file,sk,buf,bufsize) == NULL ||
+	    SkelCharReadStrokes(file,sk,buf,bufsize) == NULL)
+return NULL;
+	if (openParenExists(file)) {
+	    ungetc('(',file);
+	    if (SkelCharReadExtraSkelInfo(file,sk,buf,bufsize)==NULL)
+return NULL;
+	}
+	if (!closeParenExists(file))
+return NULL;
+    } else
+return NULL;
+
+return sk;
+}
+
+static SkelChar *getJointSkel(FILE *file, SkelChar *sk, char *buf, int bufsize) {
+    transform_matrix trans[128];
+    char *subskel_names[128];
+    int i, cnt = 0;
+
+    if (!tokCharExists(file, '\'') || !openParenExists(file) ||
+	getToken(file,buf,bufsize)==NULL || strcasecmp(buf, "joint") != 0 ||
+	!tokCharExists(file, '\'') || !openParenExists(file))
+return NULL;
+    while (!closeParenExists(file)) {
+	if (openParenExists(file)) {
+	    ungetc('(',file);
+	    if (SkelCharReadExtraSkelInfo(file,sk,buf,bufsize) == NULL ||
+		!closeParenExists(file))
+return NULL;
+    break;
+	}
+	if (!tokCharExists(file, '#') || !openParenExists(file))
+return NULL;
+ 	for (i = 0; i < 6; i++) {
+	    if (getNumeral(file,buf,bufsize)==NULL)
+return NULL;
+	    trans[cnt][i] = (real)strtod(buf, NULL);
+	}
+	if (!closeParenExists(file))
+return NULL;
+	cnt++;
+    }
+
+    if (!tokCharExists(file, '\'') || !openParenExists(file))
+return NULL;
+    for (i = 0; i < cnt; i++) {
+	if (closeParenExists(file))
+return NULL;
+	if (getToken(file,buf,bufsize)==NULL)
+return NULL;
+	subskel_names[i] = copy(buf);
+    }
+    if (!closeParenExists(file))
+return NULL;
+    if (getToken(file,buf,bufsize)==NULL || strcasecmp(buf,"nil")!=0 || !closeParenExists(file))
+return NULL;
+
+    sk->num_refs = cnt;
+    sk->subskel_names = galloc(sizeof(char *) * cnt);
+    memcpy(sk->subskel_names, subskel_names, sizeof(char *) * cnt);
+    sk->matrice = galloc(sizeof(real) * 6 * cnt);
+    memcpy(sk->matrice, trans, sizeof(real) * 6 * cnt);
+
+return sk;
+}
+
+static SkelChar *getSkeleton(FILE *file, SkelInfo *si, int *err) {
+    char buf[256];
+    const int bufsize = sizeof(buf);
+    SkelChar *sk = gcalloc(1,sizeof(SkelChar));
+
+begin:
+    if ( sk==NULL || getToken(file,buf,sizeof(buf))==NULL || *buf=='\0') {
+*err=false;
+return NULL;
+    }
+    else if (strcasecmp(buf,"(")!=0 )
+goto err;
+
+    if (!someNameExists(file,buf,bufsize)) 
+goto err;
+    if (strcasecmp(buf, "setq") == 0) {
+	if (!someNameExists(file,buf,bufsize))
+goto err;
+	if (strcasecmp(buf, "minchowidth")==0) {
+	    if (getNumeral(file,buf,bufsize)==NULL)
+goto err;
+	    si->minchowidth = (real)strtod(buf,NULL);
+	    if (!closeParenExists(file))
+goto err;
+	    else
+goto begin;
+	} else if (strcasecmp(buf, "gothicwidth")==0) {
+	    if (getNumeral(file,buf,bufsize)==NULL)
+goto err;
+	    si->gothicwidth = (real)strtod(buf,NULL);
+	    if (!closeParenExists(file))
+goto err;
+	    else
+goto begin;
+	} else {
+	    if ((sk->name=galloc(strlen(buf)+1)) == NULL)
+goto err;
+	    strcpy(sk->name, buf);
+	    if (getPrimCharOrTateYoko(file,sk,buf,bufsize) == NULL)
+goto err;
+	}
+    } else if (strcasecmp(buf, "defjoint")==0) {
+	/* accept any alphabetical string as typeface name */
+	if (getToken(file,buf,bufsize) == NULL || !isalpha(buf[0]))
+goto err;
+	if (getToken(file,buf,bufsize) == NULL ||
+	    (sk->name=galloc(strlen(buf)+1)) == NULL)
+goto err;
+	strcpy(sk->name, buf);
+	if (getJointSkel(file,sk,buf,bufsize) == NULL)
+goto err;
+    }
+
+    if (!closeParenExists(file)){
+goto err;}
+    else{
+return sk; }
+
+err:
+    *err = true;
+return fileError(file, "Error in getSkeleton(): ");
+return NULL;
+}
+
+/* If foot of perpendicular does not fall on the segment, penalty (= 1em) is added to
+   the distance from bp to nearer end of the segment */
+#include <math.h>
+#define PENALTY 1000.0
+static real distance_to_line_segment(Spline *spline, BasePoint bp) {
+    BasePoint from, to;
+    BasePoint lvec;	/* vector from->to */
+    BasePoint pvec;	/* position vector of from->bp */
+    real inner_product, square_of_line_length;
+
+    from = spline->from->me; 
+    to = spline->to->me;
+
+    lvec.x = to.x-from.x;  lvec.y = to.y-from.y;
+    pvec.x = bp.x-from.x;  pvec.y = bp.y-from.y;
+    square_of_line_length = lvec.x*lvec.x+lvec.y*lvec.y;
+    inner_product = lvec.x*pvec.x+lvec.y*pvec.y;
+
+    if ( inner_product < 0.0 )
+return sqrt((bp.x-from.x)*(bp.x-from.x)+(bp.y-from.y)*(bp.y-from.y)) + PENALTY;
+    else if ( inner_product > square_of_line_length )
+return sqrt((bp.x-to.x)*(bp.x-to.x)+(bp.y-to.y)*(bp.y-to.y)) + PENALTY;
+    else {
+        BasePoint perp;
+	perp.x = pvec.x-inner_product*lvec.x;
+	perp.y = pvec.y-inner_product*lvec.y;
+return sqrt(perp.x*perp.x+perp.y*perp.y);
+    }
+}
+
+static void insert_linkpoint_into(Spline *spline, BasePoint bp) {
+    Spline *after = chunkalloc(sizeof(Spline));
+    SplinePoint *pt = chunkalloc(sizeof(SplinePoint));
+    pt->locked = pt->islinkpt = true;
+    pt->me = bp;
+    pt->noprevcp = pt->nonextcp = true;
+    pt->next = after;
+    pt->prev = spline;
+    after->from = pt; after->to = spline->to;
+    spline->to->prev = after;
+    spline->to = pt;
+    after->to->noprevcp = true; 
+    after->islinear = after->isquadratic = true;
+    SplineRefigure2(spline);
+    SplineRefigure2(after);
+return;
+}
+
+static void insert_linkpoint(SplinePointList *spl, BasePoint bp) {
+    real min_dist = 99999.9;
+    SplinePoint *sp = spl->first;
+    Spline *nearest;
+
+    if (sp == NULL)
+return;
+    nearest = sp->next;
+    while (sp->next!=NULL) {
+	real dist = distance_to_line_segment(sp->next, bp);
+	if (min_dist < dist) {
+	    min_dist = dist;
+	    nearest = sp->next;
+	}
+	if ((sp=sp->next->to) == spl->first)
+break;
+    }
+    insert_linkpoint_into(nearest, bp);
+}
+
+static SplinePoint *LineTo(BasePoint *base, SplinePoint *from) {
+    SplinePoint *to;
+    to = chunkalloc(sizeof(SplinePoint));
+    to->me.x = base->x; to->me.y = base->y;
+    to->nextcp = to->prevcp = to->me;
+    to->nonextcp = to->noprevcp = true;
+    to->nextcpdef = to->prevcpdef = false;
+    to->ttfindex = to->nextcpindex = 0xfffe;
+    to->pointtype = pt_corner;
+    to->locked = true;
+    SplineMake2(from,to);
+return( to );
+}
+
+static SplineSet *SplineSetFromSkelChar(SkelChar *skel, real defaultwidth) {
+    SplineSet *cur=NULL, *head=NULL;
+    SplinePoint *pt, *last;
+    int i, s, p, pt_index;
+    BasePoint bp;
+
+    for (s = 0; s < skel->num_strokes; s++) {
+	SkelStroke *stroke = &skel->strokes[s];
+	SplineSet *tmp = chunkalloc(sizeof(SplineSet));
+	if (cur!=NULL) cur->next = tmp;
+	cur = tmp;
+	if (head == NULL) head = cur;
+	cur->first = cur->last = NULL;
+	cur->stroketype = stroke->stroke_type;
+	cur->width = stroke->width * defaultwidth;
+	for (p = 0; p<stroke->num_points ; p++) {
+	    if ( stroke->is_link&(1<<p))
+continue;
+	    pt_index = stroke->point_index[p];
+	    bp.x = skel->points[pt_index].x * 2.5;
+	    bp.y = skel->points[pt_index].y * -2.5 + 800;
+	    pt = chunkalloc(sizeof(SplinePoint));
+	    pt->locked = 1;
+	    pt->islinkpt = skel->points[pt_index].link_ok;
+	    pt->me = bp;
+	    pt->nextcp = pt->prevcp = pt->me;
+	    pt->noprevcp = pt->nonextcp = true;
+	    pt->nextcpdef = pt->prevcpdef = false;
+	    pt->ttfindex = pt->nextcpindex = 0xfffe;	    
+	    if (cur->first == NULL) cur->first = pt;
+	    if (cur->last != NULL)
+		SplineMake2(cur->last, pt);
+	    cur->last = pt;
+	}
+	for (p = 0; p<stroke->num_points ; p++) {
+	    if ( stroke->is_link&(1<<p) ) {
+		pt_index = stroke->point_index[p];
+		bp.x = skel->points[pt_index].x * 2.5;
+		bp.y = skel->points[pt_index].y * -2.5 + 800;
+		insert_linkpoint(cur, bp);
+	    }	
+	}
+    }
+    for (i=0; i<7; i++) {
+	DBounds *k = &skel->kamaes[i];
+	if (k->minx!=0 || k->miny!=0 || k->maxx!=0 || k->maxy!=0) {
+	    SplineSet *tmp = chunkalloc(sizeof(SplineSet));
+	    k->minx *= 2.5; k->miny = -2.5 * k->miny + 800;
+	    k->maxx *= 2.5; k->maxy = -2.5 * k->maxy + 800;
+	    if (cur!=NULL) cur->next = tmp;
+	    cur = tmp;
+	    if (head == NULL) head = cur;
+	    cur->stroketype = sk_kamae + i;
+	    cur->first = chunkalloc(sizeof(SplinePoint));
+	    cur->first->me.x = k->minx;
+	    cur->first->me.y = k->maxy;
+	    bp.x = k->minx; bp.y = k->miny;
+	    last = LineTo(&bp,cur->first);
+	    bp.x = k->maxx, bp.y = k->miny;
+	    last = LineTo(&bp,last);
+	    bp.x = k->maxx, bp.y = k->maxy;
+	    last = LineTo(&bp,last);
+	    bp.x = k->minx, bp.y = k->maxy;
+	    SplineMake(last,cur->first,true);
+	    cur->last = last;
+	}
+    }
+return head;
+}
+
+
+static RefChar *RefsFromSkelChar(SkelChar *skel, SplineChar *sc) {
+    RefChar *refs = NULL, *prev = NULL, *cur;
+    int i, j, enc = -1;
+    char *subskel_name;
+
+    sc->clwfk = skel->extra;
+    for (i = 0; i < skel->num_refs; i++) {
+	subskel_name = copy(skel->subskel_names[i]);
+	enc = SFFindGID(sc->parent, -1, subskel_name);
+	free(subskel_name);
+	if (enc < 0 || enc >= sc->parent->glyphcnt)
+goto notfound;
+
+	cur = RefCharCreate();
+
+	if (refs == NULL) refs = cur;
+	if (prev != NULL) prev->next = cur;
+
+	cur->sc = sc->parent->glyphs[enc];
+	cur->unicode_enc = cur->adobe_enc = -1;
+	cur->orig_pos = enc;
+	for (j = 0; j < 6; j++)
+	    cur->transform[j] = skel->matrice[i][j];
+	/* transform to PS coordinate system */
+	cur->transform[4] *= 2.5;
+	cur->transform[5] = cur->transform[3]*200 + (cur->transform[5]-80)*2.5;
+
+	SFDFixupRef(sc, cur);
+	prev = cur;
+    }
+return ( refs );
+
+notfound:
+    free(subskel_name);
+    if (refs)
+	RefCharFree(refs);
+return ( refs );
+}
+
+static SplineChar *SplineCharFromSkelChar(SkelChar *sk, SplineFont *sf, int enc) {
+    SplineChar *sc;
+    char buf[20];
+
+    sc = SplineCharCreate();
+    sc->parent=sf;
+    if ( sk->name!=NULL  )
+	sc->name = copy(sk->name);
+    else {
+        sprintf(buf, "unknown_%d", enc);
+	sc->name = copy(buf);
+    }
+    sc->orig_pos = enc;
+    sc->width = 1000;
+    sc->vwidth=sf->ascent+sf->descent;
+    sc->layers[ly_back].splines=NULL;
+    if (sk->num_points > 0)
+	sc->layers[ly_fore].splines = SplineSetFromSkelChar(sk, sf->strokewidth);
+    if (sk->num_refs > 0)
+	sc->layers[ly_fore].refs = RefsFromSkelChar(sk, sc);
+    sc->clwfk = sk->extra;
+return sc;
+}
+
+static void FreeSkelInfo(SkelInfo *si) {
+    const int chunksize = sizeof(((SkelChars*)NULL)->skel)/sizeof(((SkelChars*)NULL)->skel[0]);
+    SkelChars *sks = si->chars, *next;
+    int i, j;
+
+    for (sks=si->chars; si->num_skel>0; si->num_skel-=chunksize) {
+	for (i=0; i<si->num_skel && i<chunksize; i++) {
+	    if (sks->skel[i]->points!=NULL)    free(sks->skel[i]->points);
+	    if (sks->skel[i]->strokes!=NULL)   free(sks->skel[i]->strokes);
+	    if (sks->skel[i]->matrice!=NULL)   free(sks->skel[i]->matrice);
+	    if (sks->skel[i]->subskel_names!=NULL)
+		for (j=0; j<sks->skel[i]->num_refs; j++)
+		    free(sks->skel[i]->subskel_names[j]);
+	    if (sks->skel[i]->orig_def!=NULL)  free(sks->skel[i]->orig_def);
+	}
+	next=sks->next;
+	free(sks);
+	sks = next;
+    }
+}
+
+static SplineFont *NewFontFromSkelChars(SkelInfo *si) {
+    SplineFont *sf;
+    SplineChar *sc;
+    SkelChars *sks = si->chars;
+    const int chunksize = sizeof(((SkelChars*)NULL)->skel)/sizeof(((SkelChars*)NULL)->skel[0]);
+    int i = 0;
+
+    sf = SplineFontBlank(si->num_skel);
+    sf->map = EncMapNew(si->num_skel, si->num_skel, &custom);
+    sf->strokedfont = true;
+    sf->order2 = true;
+    if (si->gothicwidth != 0)
+	sf->strokewidth = si->gothicwidth * 5;
+    else if (si->minchowidth != 0)
+	sf->strokewidth = si->minchowidth * 5;
+
+    while ( i < si->num_skel ) {
+	sc = SplineCharFromSkelChar(sks->skel[i%chunksize], sf, i);
+	SFAddGlyphAndEncode(sf, sc, sf->map, i);
+	if (++i % chunksize == 0)
+	    sks = sks->next;
+    }
+    SFDCleanupFont(sf);
+    FreeSkelInfo(si);
+
+return sf;
+}
+
+SplineFont *SFReadClwfkSkeleton(char *fontname) {
+    FILE *file = fopen(fontname,"rb");
+    int err=false;
+    SkelChar *sk;
+    SkelChars *sks;
+    SkelInfo si;
+    const int chunksize = sizeof(((SkelChars*)NULL)->skel)/sizeof(((SkelChars*)NULL)->skel[0]);
+
+    si.num_skel = 0;
+    si.minchowidth = si.gothicwidth = 0.0;
+    if (file==NULL || (si.chars = gcalloc(1,sizeof(SkelChars))) == NULL)
+return NULL;
+    sks = si.chars;
+
+    while ((sk = getSkeleton(file, &si, &err)) != NULL) {
+	if (si.num_skel > 0 && si.num_skel % chunksize == 0) {
+	    if ((sks->next = gcalloc(1,sizeof(SkelChars))) == NULL) {
+	        fprintf(stderr, "memory allocation failed in %s\n", __FILE__);
+		FreeSkelInfo(&si);
+return NULL;
+	    }
+	    sks = sks->next;
+	}
+	sks->skel[si.num_skel % chunksize] = sk;
+	si.num_skel++;
+    }
+    if (err)
+return NULL;
+
+return NewFontFromSkelChars(&si);
+}
+
+static char iconvbuf[2048];
+static char *eucjp_to_utf8(const char *str) {
+    static iconv_t cvt;
+    char *bufp = iconvbuf;
+    size_t len = strlen(str);
+    size_t oleft = sizeof(iconvbuf);
+    const char **sp = &str;
+
+    if (cvt == NULL)
+	cvt = iconv_open("UTF-8", "EUC-JP");
+    iconv(cvt, sp, &len, &bufp, &oleft);
+    *bufp = '\0';
+    return iconvbuf;
+}
+
+
+SplineChar *SFReadJointGlyph(SplineFont *sf, int enc, FILE *file) {
+    SkelInfo si;
+    SkelChar *sk;
+    int i, err = false;
+    SplineChar *sc;
+
+fprintf(stderr, "SFSetClwfkSkeleton\n");
+    if ( sf->glyphs[enc] == NULL ) {
+	sf->glyphs[enc] = SplineCharCreate();
+	sc->parent = sf;
+	sc->orig_pos = enc;
+	sc->width = 1000;
+	sc->vwidth=sf->ascent+sf->descent;
+    }
+    sc = sf->glyphs[enc];
+
+    si.num_skel = 0;
+    si.minchowidth = si.gothicwidth = 0.0;
+    sk = getSkeleton(file, &si, &err);
+    if (sk == NULL)
+return NULL;
+    for (i = 0; i<sk->num_refs; i++) {
+	char *s = eucjp_to_utf8(sk->subskel_names[i]);
+	free(sk->subskel_names[i]);
+	sk->subskel_names[i] = copy(s);
+    }
+
+    if (sc->layer_cnt <= 0) {
+	sc->layers = gcalloc(sc->layer_cnt, sizeof(Layer));
+	sc->layer_cnt = 1;
+    }
+    sc->layers[ly_fore].refs = RefsFromSkelChar(sk,sc);
+//    SFDFixupRefs(sf);
+
+//    sf->glyphs[enc] = ___tmp___SplineCharFromSkelChar(sk, sf, enc);
+//    CVCharChangedUpdate(sf->glyphs[enc]->charview);
+
+return ( sf->glyphs[enc] );
+}
+
+#endif
--- fontforge/splinefill.c.orig	Tue Feb 14 10:52:20 2006
+++ fontforge/splinefill.c	Mon Mar  6 21:05:48 2006
@@ -458,6 +458,17 @@
     FindEdgesSplineSet(sc->layers[ly_fore].splines,es);
 }
 
+#ifdef FONTFORGE_CONFIG_CLWFK
+static void FindEdgesBG(SplineChar *sc, EdgeList *es) {
+    RefChar *rf;
+
+    for ( rf=sc->layers[ly_back].refs; rf!=NULL; rf = rf->next )
+	FindEdgesSplineSet(rf->layers[0].splines,es);
+
+    FindEdgesSplineSet(sc->layers[ly_back].splines,es);
+}
+#endif
+
 Edge *ActiveEdgesInsertNew(EdgeList *es, Edge *active,int i) {
     Edge *apt, *pr, *npt;
 
@@ -972,13 +983,22 @@
 	Bresenham(bytemap,es,x1,x2,y1,y2,grey);
 }
 
-static void StrokeSS(uint8 *bytemap,EdgeList *es,int width,int grey,SplineSet *ss) {
+static void StrokeSS(uint8 *bytemap,EdgeList *es,int defaultwidth,int grey,SplineSet *ss) {
     LinearApprox *lap;
     LineList *line, *prev;
     Spline *spline, *first;
+    int width = defaultwidth;
 
     for ( ; ss!=NULL; ss=ss->next ) {
 	first = NULL;
+#ifdef FONTFORGE_CONFIG_CLWFK
+	if ( ss->stroketype >= sk_kamae )
+	    width = 1.0*es->scale;
+	else if ( ss->width > 0.0 )
+	    width = rint( ss->width*es->scale );
+	else 
+	    width = defaultwidth;
+#endif
 	for ( spline = ss->first->next; spline!=NULL && spline!=first; spline=spline->to->next ) {
 	    lap = SplineApproximate(spline,es->scale);
 	    if ( lap->lines!=NULL ) {
@@ -1214,9 +1234,19 @@
 	    } else
 #endif
 	    if ( sc->parent->strokedfont ) {
+#ifdef FONTFORGE_CONFIG_CLWFK
+	        if ( sc->layers[ly_back].splines ) {
+		    FindEdgesBG(sc,&es);
+		    FillChar(&es);
+		    depth = 0;
+		} else {
+#endif
 		uint8 *bytemap = gcalloc(es.cnt*es.bytes_per_line*8,1);
 		StrokeGlyph(bytemap,&es,sc->parent->strokewidth,sc);
 		depth = FigureBitmap(&es,bytemap,is_aa);
+#ifdef FONTFORGE_CONFIG_CLWFK
+	        }
+#endif
 	    } else {
 		FindEdges(sc,&es);
 		FillChar(&es);
--- fontforge/splinefont.h.orig	Thu Oct 26 22:52:24 2006
+++ fontforge/splinefont.h	Sun Nov 12 12:07:11 2006
@@ -27,6 +27,9 @@
 #ifndef _SPLINEFONT_H
 #define _SPLINEFONT_H
 
+#define FONTFORGE_CONFIG_CLWFK 1
+#define FONTFORGE_CONFIG_HUGE_FONTVIEW 1
+
 #include "basics.h"
 #include "configure-pfaedit.h"
 #ifdef HAVE_ICONV_H
@@ -646,6 +649,10 @@
     unsigned int ticked: 1;
     unsigned int watched: 1;
 	/* 1 bits left... */
+#ifdef FONTFORGE_CONFIG_CLWFK
+    unsigned int locked: 1;	/* don't join to other open path */
+    unsigned int islinkpt: 1;	/* move all snapped points simultaneously */
+#endif
     uint16 ptindex;		/* Temporary value used by metafont routine */
     uint16 ttfindex;		/* Truetype point index */
 	/* Special values 0xffff => point implied by averaging control points */
@@ -707,9 +714,28 @@
     */
 } Spline;
 
+#ifdef FONTFORGE_CONFIG_CLWFK
+enum stroke {
+     sk_ten, sk_tate, sk_yoko, sk_migiue, sk_hidari, sk_tatehidari, sk_migi, 
+     sk_kozato, sk_tatehane, sk_tsukurihane, sk_sanzui, sk_kokoro, sk_tasuki,
+     sk_shin_nyuu, sk_magaritate, sk_kagi, 
+     /* sk_hira0, sk_hira1, sk_hira2, sk_hira3, */ 
+     sk_hira_long,
+     sk_kamae, sk_kamae1, sk_kamae2, sk_nyou, sk_tare,
+     num_enum_stroke
+};
+extern const char *stroketypes[num_enum_stroke];
+extern const unichar_t *u_stroketypes[num_enum_stroke];
+extern const int num_edges_in_strokes[num_enum_stroke];
+#endif
+
 typedef struct splinepointlist {
     SplinePoint *first, *last;
     struct splinepointlist *next;
+#ifdef FONTFORGE_CONFIG_CLWFK
+    real width;
+    enum stroke stroketype;
+#endif
 } SplinePointList, SplineSet;
 
 typedef struct imagelist {
@@ -883,7 +909,24 @@
 } Layer;
 
 enum layer_type { ly_grid= -1, ly_back=0, ly_fore=1 /* Possibly other foreground layers for multi-layered things */ };
-    
+
+#ifdef FONTFORGE_CONFIG_CLWFK
+typedef struct skel_params {
+    unichar_t *jointdef;
+    real xlimit_min, xlimit_max;
+    real ylimit_min, ylimit_max;
+    real tateheight;
+    real yokowidth;
+    real xunit;
+    real yunit;
+    real center;
+    real width;
+    real up;
+    real down;
+    char *hook;
+} SkelParams;
+#endif
+
 typedef struct splinechar {
     char *name;
     int unicodeenc;
@@ -952,6 +995,9 @@
     int16 tex_height, tex_depth;
     int16 tex_sub_pos, tex_super_pos;	/* Only for math fonts */
     struct altuni { struct altuni *next; int unienc; } *altuni;
+#ifdef FONTFORGE_CONFIG_CLWFK
+    SkelParams clwfk;
+#endif
 } SplineChar;
 
 #define TEX_UNDEF 0x7fff
@@ -1117,6 +1163,9 @@
     struct otfname *fontstyle_name;
     uint16 design_range_bottom, design_range_top;
     real strokewidth;
+#ifdef FONTFORGE_CONFIG_CLWFK
+    enum stroke last_stroketype;
+#endif
 /* For GDEF Mark Attachment Class -- used in lookup flags */
 /* As usual, class 0 is unused */
     int mark_class_cnt;
@@ -1253,7 +1302,11 @@
 	ff_ptype3, ff_ptype0, ff_cid, ff_cff, ff_cffcid,
 	ff_type42, ff_type42cid,
 	ff_ttf, ff_ttfsym, ff_ttfmacbin, ff_ttfdfont, ff_otf, ff_otfdfont,
+#ifdef FONTFORGE_CONFIG_CLWFK
+	ff_otfcid, ff_otfciddfont, ff_svg, ff_clwfk, ff_none };
+#else
 	ff_otfcid, ff_otfciddfont, ff_svg, ff_none };
+#endif
 extern struct pschars *SplineFont2ChrsSubrs(SplineFont *sf, int iscjk,
 	struct pschars *subrs,int flags,enum fontformat format);
 extern int CanonicalCombiner(int uni);
@@ -2057,6 +2110,24 @@
 
 extern void DefaultOtherSubrs(void);
 extern int ReadOtherSubrsFile(char *filename);
+#endif
+
+#ifdef FONTFORGE_CONFIG_CLWFK
+extern SplineFont *SFReadClwfkSkeleton(char *fontname);
+extern void SCBuildSkeleton(SplineChar *sc, char *name);
+extern void SCFleshSkeleton(SplineChar *sc, char *face, int normkanji);
+extern void StrokeGetInfo(struct charview *cv, SplinePointList *spl, int selected_num);
+extern int ExportNamedPrimitive(FILE *skel, SplineChar *sc, char *glyphname);
+extern int ExportPrimitive(FILE *skel, SplineChar *sc);
+extern int ExportSkeleton(FILE *skel, SplineChar *sc, int use_jointdef);
+extern int ExportSkeletonAndDepends(FILE *skel, SplineChar *sc);
+extern char *u2utf7_copy(const unichar_t *ubuf);
+extern char *utf82utf7_copy(const char *buf);
+extern int SkeletonCheck(SplineChar *sc);
+extern void SCAddDependents(SplineChar *sc, char *defstr, char *face);
+extern void SFAddSkelChar(SplineFont *sf, char *defstr);
+extern SplineChar *SFReadJointGlyph(SplineFont *sf, int enc, FILE *file);
+extern void SFAddOneCharFromSkeleton(SplineFont *sf, int enc, char *defstr);
 
 extern char *utf8toutf7_copy(const char *_str);
 extern char *utf7toutf8_copy(const char *_str);
--- fontforge/splineorder2.c.orig	Mon Sep 18 08:27:42 2006
+++ fontforge/splineorder2.c	Sun Nov 12 12:08:09 2006
@@ -811,6 +811,10 @@
 	memcpy(ret->first->hintmask,ss->first->hintmask,sizeof(HintMask));
     }
     ret->last = ret->first;
+#ifdef FONTFORGE_CONFIG_CLWFK
+    ret->width = ss->width;
+    ret->stroketype = ss->stroketype;
+#endif
 
     first = NULL;
     for ( spline=ss->first->next; spline!=NULL && spline!=first; spline=spline->to->next ) {
@@ -863,6 +867,10 @@
 	memcpy(ret->first->hintmask,ss->first->hintmask,sizeof(HintMask));
     }
     ret->last = ret->first;
+#ifdef FONTFORGE_CONFIG_CLWFK
+    ret->width = ss->width;
+    ret->stroketype = ss->stroketype;
+#endif
 
     first = NULL;
     for ( spline=ss->first->next; spline!=NULL && spline!=first; spline=spline->to->next ) {
--- fontforge/splineutil.c.orig	Sat Oct  7 21:27:02 2006
+++ fontforge/splineutil.c	Sun Nov 12 12:08:29 2006
@@ -1140,6 +1140,10 @@
     Spline *spline;
 
     cur = chunkalloc(sizeof(SplinePointList));
+#ifdef FONTFORGE_CONFIG_CLWFK
+    cur->width = spl->width;
+    cur->stroketype = spl->stroketype;
+#endif
 
     for ( pt=spl->first; ;  ) {
 	cpt = chunkalloc(sizeof(SplinePoint));
--- fontforge/start.c.orig	Sat Sep  2 23:35:40 2006
+++ fontforge/start.c	Sun Nov 12 12:08:48 2006
@@ -818,3 +818,23 @@
 #endif
 return( 0 );
 }
+
+#ifdef FONTFORGE_CONFIG_CLWFK
+int FontForgeMainWithNoArgs( void ) {
+    int argc = 0;
+    char argv0[] = "fontforge";
+    char argv1[] = "";
+    char *argv[] = { argv0, argv1, NULL };
+
+return( FontForgeMain(argc, argv) );
+}
+
+#if 0
+#include "zzzzz-clwfk.h"
+A_Skel Skel;
+
+A_Skel *dummy (A_Skel *p) {
+    return p;
+}
+#endif
+#endif
--- fontforge/views.h.orig	Tue Oct 24 09:14:09 2006
+++ fontforge/views.h	Sun Nov 12 12:09:48 2006
@@ -53,6 +53,9 @@
     int showblues, showfamilyblues;
     int showanchor;
     int showcpinfo;
+#ifdef FONTFORGE_CONFIG_CLWFK
+    int normkanji;
+#endif
 } CVShows;
 
 extern struct bvshows {
@@ -254,6 +257,9 @@
     unsigned int coderange: 2;			/* For the debugger */
     unsigned int autonomous_ruler_w: 1;
     unsigned int showcpinfo: 1;
+#ifdef FONTFORGE_CONFIG_CLWFK
+    unsigned int normkanji: 1;
+#endif
     Layer *layerheads[dm_max];
     real scale;
 #if defined(FONTFORGE_CONFIG_GTK)
@@ -699,6 +705,9 @@
 enum fvformats { fv_bdf, fv_ttf, fv_pk, fv_pcf, fv_mac, fv_win, fv_palm,
 	fv_image, fv_imgtemplate, fv_eps, fv_epstemplate,
 	fv_svg, fv_svgtemplate,
+#ifdef FONTFORGE_CONFIG_CLWFK
+	fv_skel,
+#endif
 	fv_fig };
 extern int HasSVG(void);
 extern void SCImportSVG(SplineChar *sc,int layer,char *path,char  *memory, int memlen,int doclear);
@@ -1033,6 +1042,10 @@
 	RefChar **ref, ImageList **img, AnchorPoint **ap);
 extern int CVOneContourSel(CharView *cv, SplinePointList **_spl,
 	RefChar **ref, ImageList **img);
+#ifdef FONTFORGE_CONFIG_CLWFK
+extern int CVPointsSel(CharView *cv,  SplinePointList **_spl,
+			  int *selected_num);
+#endif
 extern void RevertedGlyphReferenceFixup(SplineChar *sc, SplineFont *sf);
 extern void CVImport(CharView *cv);
 extern void BVImport(BitmapView *bv);
--- fontforge/zzzzz-clwfk.h.orig	Sun Nov 12 12:18:32 2006
+++ fontforge/zzzzz-clwfk.h	Sun Nov 12 12:16:57 2006
@@ -0,0 +1,67 @@
+#ifndef _CLWFK_H_
+#define _CLWFK_H_
+
+/*
+ *  Skeleton.
+ */
+typedef struct alien_stroke {
+    int type;
+    float width;
+    int points[4];
+    int njoints;
+    int joints[8];
+} A_Stroke;
+
+typedef struct alien_point {
+    int isjoint;
+    int isendpt;
+    float from_x;
+    float from_y;
+    float to_x;
+    float to_y;
+} A_Point;
+
+typedef struct alien_skel {
+    int npoints;
+    int nstrokes;
+    A_Point  points[512];
+    A_Stroke strokes[128];
+    float xlimit_min, xlimit_max;
+    float ylimit_min, ylimit_max;
+    float tateheight;
+    float yokowidth;
+    float xunit;
+    float yunit;
+    float center;
+    float width;
+    float up;
+    float down;
+} A_Skel;
+
+/*
+ * Rendered outlines.
+ */
+typedef struct alien_contourpoint {
+    int is_endpoint;
+    float x;
+    float y;
+} A_CPoint;
+
+typedef struct alien_contour {
+    int size;
+    A_CPoint points[128];
+} A_Contour;
+
+typedef struct alien_outline {
+    int size;
+    A_Contour contours[64];
+} A_Outline;
+
+/* 
+
+TODO: C ǽ񤯴ؿ
+ A_Outline  SplineSet ѴХå饦ɤ˽񤭹ࡣ
+ȥ󤫤
+
+ */
+#endif
--- po/ja.po.orig	Fri Mar 10 10:19:12 2006
+++ po/ja.po	Sun Mar 12 15:38:01 2006
@@ -12258,3 +12258,102 @@
 
 msgid "No such file"
 msgstr "そのようなファイルはありません"
+
+msgid "CLWFK"
+msgstr "CLWFK"
+
+msgid "Lock/Unlock Line _End"
+msgstr "線端をロック/解除(_E)"
+
+msgid "Set/Unset as Link _Point"
+msgstr "リンク点にセット/解除(_P)"
+
+msgid "_Stroke Info"
+msgstr "ストローク情報(_S)"
+
+msgid "Stroke Info"
+msgstr "ストローク情報"
+
+msgid "Stroke Type:"
+msgstr "ストロークタイプ:"
+
+msgid "This dialog sets information about a CLWFK primitive"
+msgstr "このダイアログは CLWFK のプリミティブに関する情報を設定します"
+
+msgid "Prim Name:"
+msgstr "プリミティブ名:"
+
+msgid "tateheight:"
+msgstr "tateheight:"
+
+msgid "yokowidth:"
+msgstr "yokowidth:"
+
+msgid "TateH/YokoW:"
+msgstr "TateH/YokoW:"
+
+msgid "'tateheight' and 'yokowidth'."
+msgstr "'tateheight' と 'yokowidth'."
+
+msgid "width:"
+msgstr "width:"
+
+msgid "center"
+msgstr "center"
+
+msgid "width/center:"
+msgstr "width/center:"
+
+msgid "xunit:"
+msgstr "xunit:"
+
+msgid "yunit:"
+msgstr "yunit:"
+
+msgid "xunit/yunit:"
+msgstr "xunit/yunit:"
+
+msgid "updown:"
+msgstr "updown:"
+
+msgid "hook:"
+msgstr "hook:"
+
+msgid "Show Mincho Outline"
+msgstr "明朝体のアウトラインを表示"
+
+msgid "Show Gothic Outline"
+msgstr "ゴシックのアウトラインを表示"
+
+msgid "Normalize Kanji Size"
+msgstr "漢字サイズを規格化"
+
+msgid "CLWFK renderer not found"
+msgstr "CLWFK のレンダラが見つかりません"
+
+msgid "Lisp interpreter (CMUCL) not found"
+msgstr "Lispインタプリタ(CMUCL)が見つかりません"
+
+msgid "Rendering error happend"
+msgstr "肉付け処理にエラーが発生しました"
+
+msgid "Bad Skeleton"
+msgstr "不正なスケルトン"
+
+msgid "Failed to export skeleton, because%s needs %d points but there are %d"
+msgstr "スケルトンの書き出しに失敗しました.%sは %d 個の点が必要ですが,%d個しかありません"
+
+msgid "Part Name:"
+msgstr "部品名:"
+
+msgid "Joint Def:"
+msgstr "組合せ定義:"
+
+msgid "Origianal definition of combinied components"
+msgstr "部品組合せのオリジナル定義"
+
+msgid "Re-Expand Joint Definition"
+msgstr "組合せ定義を再展開"
+
+msgid "CLWFK Skeleton"
+msgstr "CLWFKスケルトン"
--- Makefile.dynamic.in.orig	Thu Oct 26 23:21:01 2006
+++ Makefile.dynamic.in	Sun Nov 12 11:18:10 2006
@@ -53,8 +53,8 @@
 	$(LIBTOOL) --mode=install $(INSTALL) -c libgunicode.la $(libdir)/libgunicode.la
 	$(LIBTOOL) --mode=install $(INSTALL) -c libgdraw.la $(libdir)/libgdraw.la
 	$(LIBTOOL) --mode=finish $(libdir)
-	mkdir -p $(libdir)/pkgconfig
-	$(INSTALL_DATA) fontforge.pc $(libdir)/pkgconfig
+	mkdir -p ${PREFIX}/libdata/pkgconfig
+	$(INSTALL_DATA) fontforge.pc ${PREFIX}/libdata/pkgconfig
 
 install_docs:
 	mkdir -p $(docdir)
@@ -75,6 +75,7 @@
 	mkdir -p $(sharedir)
 	$(LIBTOOL) --mode=install $(INSTALL) -c fontforge/fontforge $(bindir)
 	$(LIBTOOL) --mode=install $(INSTALL) -c fontforge/sfddiff $(bindir)
+#	$(LIBTOOL) --mode=install $(INSTALL) -c fontforge/acorn2sfd $(bindir)
 	$(LIBTOOL) --mode=install $(INSTALL) -c fontforge/fontimage $(bindir)
 #	-rm -f $(bindir)/pfaedit
 #	(cd $(bindir) ; ln -s fontforge pfaedit)
@@ -93,6 +94,7 @@
 uninstall:
 	-rm $(bindir)/fontforge
 	-rm $(bindir)/sfddiff
+	-rm $(bindir)/acorn2sfd
 	-rm $(sharedir)/pfaedit-*.ui
 	-rm $(localedir)/*/LC_MESSAGES/FontForge.mo
 	-rm $(mandir)/man1/fontforge.1
--- fontforge/configure-pfaedit.h.orig	Sat Jan  8 11:11:45 2005
+++ fontforge/configure-pfaedit.h	Thu Jan 20 16:53:29 2005
@@ -73,7 +73,7 @@
 /* Sometimes I want to create a glyph which is a word, and this command       */
 /*  makes that easy                                                           */
 /*									      */
-/* #define FONTFORGE_CONFIG_PASTEAFTER					      */
+#define FONTFORGE_CONFIG_PASTEAFTER
 /*									      */
 /* The paste after command pastes the contents of the clipboard into the      */
 /*  current glyph, translates that by the advance width of the current glyph  */
@@ -84,7 +84,7 @@
 /*  don't include code for it by default, but if you do want it simply define */
 /*  the following macro							      */
 /*									      */
-/* #define FONTFORGE_CONFIG_TILEPATH					      */
+#define FONTFORGE_CONFIG_TILEPATH
 /*									      */
 /* The tile path command uses the contents of the clipboard as a tile which is*/
 /*  applied to any selected paths, replacing them. It could be used to make a */
@@ -190,7 +190,7 @@
 /*  routine. I'm not sure that it's very useful though. It can be used to do  */
 /*  perspective transformations and such				      */
 /*									      */
-/* #define FONTFORGE_CONFIG_NONLINEAR					      */
+#define FONTFORGE_CONFIG_NONLINEAR
 /*									      */
 /* This command takes two strings which specify general expressions in x and y*/
 /*  and applies the specified transformations to the splines.  Note: Each     */
--- plugins/Makefile.in.orig	Fri Aug 25 11:29:08 2006
+++ plugins/Makefile.in	Mon Oct 16 13:17:26 2006
@@ -20,7 +20,7 @@
     @CPPFLAGS@ '-DPREFIX="@prefix@"'
 CFLAGS = @CFLAGS@ $(_CFLAGS)
 
-LIBS = -rpath $(libdir)  -L/usr/lib -lm
+LIBS = -rpath $(libdir)  -L/usr/lib -L/usr/local/lib -lm
 
 PLUGINS = gb12345.la
 
